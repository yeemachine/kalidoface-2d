/*! For license information please see lib-tfjs-backend-webgl.071c588f3c2729ca350a.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{163:function(e,t,n){"use strict";n(35),n(19),n(28),n(25),n(31),n(9);var r=n(0),a=n(7);const o={},s={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function i(e){if(!(e in o)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);if(t.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete o[e]}),!1),1===e)return t.getContext("webgl",s)||t.getContext("experimental-webgl",s);return t.getContext("webgl2",s)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;o[e]=t}const t=o[e];return t.isContextLost()?(delete o[e],i(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),o[e])}var c,u,l;function d(e,t){return[t,e]}function p(e){const t=Object(r.Ec)(e),n=Math.ceil(t/4);return Object(r.Sd)(n)}function h(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function f(e,t){const n=e;let a,o,s,i,c,u,l,d,p,h;return 2===Object(r.Bf)().getNumber("WEBGL_VERSION")?(a=n.R32F,o=n.R16F,s=n.RGBA16F,i=n.RGBA32F,c=n.RED,l=4,d=1,p=n.HALF_FLOAT,h=n.FLOAT):(a=e.RGBA,o=e.RGBA,s=e.RGBA,i=n.RGBA,c=e.RGBA,l=4,d=4,p=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT),u=e.RGBA,{internalFormatFloat:a,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:c,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:h}}function x(e,t){const n=t();return Object(r.Bf)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+m(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(c||(c={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(u||(u={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(l||(l={}));function g(e){return!!(Object(r.Bf)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function m(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function b(e,t){return j(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function C(e,t){const n=j(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(x(e,(()=>e.shaderSource(n,t))),x(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function $(e,t){const n=j(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(x(e,(()=>e.shaderSource(n,t))),x(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=v.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const a=+n[1],o=e.split("\n"),s=o.length.toString().length+2,i=o.map(((e,t)=>Object(r.Td)((t+1).toString(),s)+e));let c=0;for(let e=0;e<i.length;e++)c=Math.max(i[e].length,c);const u=i.slice(0,a-1),l=i.slice(a-1,a),d=i.slice(a);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Object(r.Td)(l[0],c)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const v=/ERROR: [0-9]+:([0-9]+):/g;function I(e){return j(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function R(e,t){if(x(e,(()=>e.linkProgram(t))),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function O(e,t){if(x(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function w(e,t){const n=j(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),x(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function k(e,t){const n=j(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return x(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),x(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function y(e){return j(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function E(e,t){const n=Object(r.Bf)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function N(e){return j(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function T(e,t,n,r,a,o,s){const i=e.getAttribLocation(t,n);return-1!==i&&(x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),x(e,(()=>e.vertexAttribPointer(i,a,e.FLOAT,!1,o,s))),x(e,(()=>e.enableVertexAttribArray(i))),!0)}function F(e,t,n){W(e,n),x(e,(()=>e.activeTexture(e.TEXTURE0+n))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function A(e,t,n){return j(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function S(e,t,n){return e.getUniformLocation(t,n)}function _(e,t,n,r){x(e,(()=>F(e,t,r))),x(e,(()=>e.uniform1i(n,r)))}function L(e,t,n){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),x(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function D(e,t){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),x(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function P(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+B(e,t))}function B(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function j(e,t,n){const r=x(e,(()=>t()));if(null==r)throw new Error(n);return r}function W(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function V(e,t=2){return Object(r.Ec)(e.slice(0,e.length-t))}function M(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function U(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[V(e),...M(e)]),t}function G(e,t=!1){let n=Object(r.Bf)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Object(r.Ud)(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Object(r.Vd)(e);e=t.newShape}let a=Object(r.Ec)(e);if(e.length<=1&&a<=n)return[1,a];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=V(e);let n=2,o=2;return e.length&&([n,o]=M(e)),a=t*(n/2)*(o/2),Object(r.Sd)(a).map((e=>2*e))}return Object(r.Sd)(a)}function z(e){return e%2==0}function X(e,t){if(e=e.slice(-2),t=t.slice(-2),Object(r.gb)(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(z(n)&&z(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&z(e[0])&&z(t[0])}let H,K;function Y(e){if(null==H){const t=i(e);H=t.getParameter(t.MAX_TEXTURE_SIZE)}return H}function q(e){if(null==K){const t=i(e);K=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,K)}function Q(e){if(0===e)return 0;let t;const n=i(e);return t=Z(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Z(n,"EXT_disjoint_timer_query")?1:0,t}function Z(e,t){return null!=e.getExtension(t)}function J(e){try{if(null!=i(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function ee(e){if(0===e)return!1;const t=i(e);if(1===e){if(!Z(t,"OES_texture_float"))return!1}else if(!Z(t,"EXT_color_buffer_float"))return!1;return ne(t)}function te(e){if(0===e)return!1;const t=i(e);if(1!==e){if(Z(t,"EXT_color_buffer_float"))return ne(t);const e="EXT_color_buffer_half_float";if(Z(t,e)){const n=t.getExtension(e);return function(e,t){const n=f(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),i}(t,n)}return!1}if(!Z(t,"OES_texture_float"))return!1;if(!Z(t,"WEBGL_color_buffer_float"))return!1;return ne(t)}function ne(e){const t=f(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function re(e){if(2!==e)return!1;return null!=i(e).fenceSync}function ae(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Object(r.F)("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const oe=Object(r.Bf)();function se(){let e,t,n,a,o,s,i,c,u,l;return 2===Object(r.Bf)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",o="texture",s="outputColor",i="out vec4 outputColor;",c="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",o="texture2D",s="gl_FragColor",i="",c="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:c,defineSpecialInf:u,defineRound:l}}function ie(e,t,n="index"){const a=Object(r.Xd)(t);return a.map(((t,r)=>`${`int ${e[r]} = ${n} / ${t}`}; ${r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`)).join("")}function ce(e){const t=Object(r.Xd)(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}oe.registerFlag("HAS_WEBGL",(()=>oe.getNumber("WEBGL_VERSION")>0)),oe.registerFlag("WEBGL_VERSION",(()=>J(2)?2:J(1)?1:0)),oe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),oe.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===oe.get("WEBGL_VERSION"))),oe.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),oe.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),oe.registerFlag("WEBGL_PACK",(()=>oe.getBool("HAS_WEBGL"))),oe.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_PACK_CLIP",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>!1)),oe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_PACK_REDUCE",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_LAZILY_UNPACK",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_CONV_IM2COL",(()=>oe.getBool("WEBGL_PACK"))),oe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>Y(oe.getNumber("WEBGL_VERSION")))),oe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>q(oe.getNumber("WEBGL_VERSION")))),oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=oe.getNumber("WEBGL_VERSION");return 0===e?0:Q(e)})),oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>oe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Object(r.Wd)())),oe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>ee(oe.getNumber("WEBGL_VERSION")))),oe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!oe.getBool("WEBGL_FORCE_F16_TEXTURES")&&oe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),oe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>te(oe.getNumber("WEBGL_VERSION")))),oe.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>re(oe.getNumber("WEBGL_VERSION")))),oe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>oe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),oe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}));const ue="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class le{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=c.DENSE;const t=p(e),n=se();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${ie(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class de{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=c.DENSE;const t=p(e),n=se();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${ie(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class pe{constructor(e){this.variableNames=["A"],this.outTexUsage=u.DOWNLOAD;const t=se();this.outputShape=e,this.userCode=`\n      ${ue}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class he{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=u.DOWNLOAD;const t=se();this.outputShape=e,this.userCode=`\n      ${ue}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class fe{constructor(e,t,n=!1){this.variableNames=["A"];const r=se(),[a,o]=t;this.outputShape=e;let s="result";n&&(s="floor(result * 255. + 0.5)"),this.userCode=`\n      ${ce(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${o};\n        int c = imod(flatIndex, ${o});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${a}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class xe{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=se(),[a,o]=t;this.outputShape=e;let s="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){const i=2*t+n;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${e[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${t} < ${e[1]}) {\n              localCoords[1] += ${t};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${o};\n              c = imod(flatIndex, ${o});\n              uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${a}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${i}] = values[0];\n              } else if(offset == 1) {\n                result[${i}] = values[1];\n              } else if(offset == 2) {\n                result[${i}] = values[2];\n              } else {\n                result[${i}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${ce(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${s}\n\n        ${r.output} = ${i};\n      }\n    `}}function ge(e){const t=se();return C(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function me(e){return w(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function be(e){return k(e,new Uint16Array([0,1,2,2,1,3]))}function Ce(e,t,n,r,a,o){E(t,n);const s=y(e),i=e.TEXTURE_2D;return x(e,(()=>e.bindTexture(i,s))),x(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),x(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),x(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),x(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),x(e,(()=>e.texImage2D(i,0,r,t,n,0,a,o,null))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),s}function $e(e){return e.internalFormatFloat}function ve(e,t,n,r){const[a,o]=d(t,n);return Ce(e,a,o,$e(r),r.textureFormatFloat,e.FLOAT)}function Ie(e){return e.internalFormatHalfFloat}function Re(e,t,n,r){const[a,o]=d(t,n);return Ce(e,a,o,Ie(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Oe(e){return e.downloadTextureFormat}function we(e,t,n,r){const[a,o]=d(t,n);return Ce(e,a,o,Oe(r),e.RGBA,e.UNSIGNED_BYTE)}function ke(e){return e.internalFormatPackedFloat}function ye(e,t,n,r){const[a,o]=h(t,n);return Ce(e,a,o,ke(r),e.RGBA,e.FLOAT)}function Ee(e){return e.internalFormatPackedHalfFloat}function Ne(e,t,n,r){const[a,o]=h(t,n);return Ce(e,a,o,Ee(r),e.RGBA,r.textureTypeHalfFloat)}function Te(e,t,n){x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));return T(e,t,"clipSpacePos",n,3,20,0)&&T(e,t,"uv",n,2,20,12)}function Fe(e,t,n,r,a,o){let s,i,c;x(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(s=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(s=new Float32Array(n*r*4),i=e.FLOAT,c=o.internalFormatPackedFloat),s.set(a),x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,r,0,e.RGBA,i,s))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Ae(e,t,n){x(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Se(e,t,n,r){const a=e.createBuffer();x(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));const o=16*t*n;return x(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),x(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),x(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function _e(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function Le(e,t,n,r){const[a,o]=d(t,n),s=new Uint8Array(t*n*4);return x(e,(()=>e.readPixels(0,0,a,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}function De(e,t,n,r,a,o,s,i){const c=e,u=new Float32Array(function(e,t){const[n,r]=h(e,t);return n*r*4}(o,s));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,u),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),u}function Pe(e,t,n){const r=new Float32Array(t*n*4);return x(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}class Be{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Object(r.Bf)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){o[e]=t}(t,e)):this.gl=i(t);let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(1===Object(r.Bf)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=b(this.gl,e),Z(this.gl,t))this.textureHalfFloatExtension=b(this.gl,t);else if(Object(r.Bf)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Z(this.gl,a))this.colorBufferHalfFloatExtension=b(this.gl,a);else if(Object(r.Bf)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Z(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Z(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=me(this.gl),this.indexBuffer=be(this.gl),this.framebuffer=N(this.gl),this.textureConfig=f(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(r.Bf)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;x(e,(()=>e.finish())),x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),x(e,(()=>e.deleteFramebuffer(this.framebuffer))),x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),x(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),x(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),ve(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Re(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),we(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Ae(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Fe(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Ne(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),ye(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(D(this.gl,this.framebuffer),this.outputTexture=null),x(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Le(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,o){return De(this.gl,e,0,0,0,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return _e(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=Se(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(r.Bf)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Pe(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=$(t,e),r=ge(t),a=I(t);return x(t,(()=>t.attachShader(a,r))),x(t,(()=>t.attachShader(a,n))),R(t,a),this.debug&&O(t,a),this.vertexAttrsAreBound||(this.setProgram(a),this.vertexAttrsAreBound=Te(t,this.program,this.vertexBuffer)),a}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&x(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&O(this.gl,this.program),x(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?A(this.gl,e,t):S(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),x(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),_(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=h(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&O(this.gl,this.program),P(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),x(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),x(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=b(this.gl,2===Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Object(r.Yd)((()=>this.disposed||this.isQueryAvailable(e,Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||Object(r.Yd)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),L(this.gl,e,this.framebuffer),this.debug&&P(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(L(this.gl,this.outputTexture,this.framebuffer),this.debug&&P(this.gl)):D(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;L(r,e,this.framebuffer),this.debug&&P(r),this.outputTexture=e,x(r,(()=>r.viewport(0,0,t,n))),x(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),x(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:je}=a.c;function We(e,t,n,a){const o=[];e.forEach((e=>{const t=Object(r.Ec)(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?o.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(o.push(`uniform sampler2D ${e.name};`),o.push(`uniform int offset${e.name};`))}));const s=o.join("\n"),i=e.map((e=>function(e,t,n=!1){let a="";a+=n?Me(e):Ve(e);const o=e.shapeInfo.logicalShape,s=t.logicalShape;o.length<=s.length&&(a+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),o="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,c=je(e.shapeInfo.logicalShape,t.logicalShape),u=qe(i),l=i-s;let d;const p=["x","y","z","w","u","v"];d=0===s?"":i<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+l]} = 0;`)).join("\n");let h="";h=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+l]}`)).join(", ");let f="return outputValue;";const x=1===Object(r.Ec)(e.shapeInfo.logicalShape),g=1===Object(r.Ec)(t.logicalShape);if(1!==s||x||g){if(x&&!g)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(c.length){const e=s-2,t=s-1;c.indexOf(e)>-1&&c.indexOf(t)>-1?f="return vec4(outputValue.x);":c.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":c.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${a}(${h});\n      ${f}\n    }\n  `}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),o="get"+a+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,c=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&c===u&&null==e.shapeInfo.flatOffset&&Object(r.gb)(i,s))return`\n      float ${o}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=qe(u),d=je(e.shapeInfo.logicalShape,t.logicalShape),p=u-c;let h;const f=["x","y","z","w","u","v"];h=0===c?"":u<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${f[e+p]} = 0;`)).join("\n");let x="";x=u<2&&c>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${f[t+p]}`)).join(", ");return`\n    float ${o}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${a}(${x});\n    }\n  `}(e,t));return a}(e,t,a))).join("\n"),c=t.texShape,u=se(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let d,p,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Ue}\n    ${Ge}\n    ${ze}\n  `}(u);t.isPacked?(d=function(e,t){switch(e.length){case 0:return He();case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===n[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Object(r.gb)(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),a=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),a=r*Math.ceil(e[e.length-2]/2);let o=a,s="",i="b, r, c";for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],s=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+s,i=`b${t}, `+i;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${s}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${i});\n    }\n  `}(e,t)}}(t.logicalShape,c),p=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(d=function(e,t){switch(e.length){case 0:return He();case 1:return function(e,t){if(1===t[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t);case 2:return function(e,t){if(Object(r.gb)(e,t))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=ie(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=ie(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=ie(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=ie(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,c),p=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),a&&(h+=Xe);return[h,l,p,s,d,i,n].join("\n")}function Ve(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,a]=e.shapeInfo.texShape;if(1===r&&1===a)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[o,s]=e.shapeInfo.texShape,i=Ke(t);return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${o}, ${s}, ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Ye(e)}\n      }\n    `;const r=e.shapeInfo.texShape,a=r[0],o=r[1];if(1===o&&1===a)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const s=Ke(t);if(1===o)return`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${a}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===a)return`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${o}, index + ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape;if(null!=o&&Object(r.gb)(t,o)){const e=o[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${e}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:s,keptDims:i}=Object(r.Vd)(t),c=s;if(c.length<t.length){const t=["row","col"];return`\n      ${Ve(Qe(e,c))}\n      float ${a}(int row, int col) {\n        return ${a}(${Ze(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${Ye(e)}\n      }\n    `;const u=o[0],l=o[1],d=Ke(n);if(1===l)return`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;if(1===u)return`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[1]*t[2],s=t[2],{newShape:i,keptDims:c}=Object(r.Vd)(t),u=i;if(u.length<t.length){const t=["row","col","depth"];return`\n        ${Ve(Qe(e,u))}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${Ze(t,c)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${s}, 1)));\n        ${Ye(e)}\n      }\n    `;const l=e.shapeInfo.texShape,d=l[0],p=l[1],h=e.shapeInfo.flatOffset;if(p===o&&null==h)return`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${d}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(p===s&&null==h)return`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const f=Ke(n);return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${s} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${p}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[3],s=t[2]*o,i=t[1]*s,{newShape:c,keptDims:u}=Object(r.Vd)(t);if(c.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${Ve(Qe(e,c))}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${Ze(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${s}, ${o}, 1)));\n        ${Ye(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&null==l)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===o&&null==l)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=Ke(n);return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${s} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${h}, index + ${f});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,c=t[1]*i,{newShape:u,keptDims:l}=Object(r.Vd)(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${Ve(Qe(e,u))}\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        return ${a}(${Ze(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${i}, ${s}, ${o})) +\n          depth3;\n        ${Ye(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===c&&null==d)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const x=Ke(n);return`\n    float ${a}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${i} + depth * ${s} +\n          depth2 * ${o} + depth3 + ${x};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:o,keptDims:s}=Object(r.Vd)(t);if(o.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ve(Qe(e,o))}\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${a}(${Ze(t,s)});\n      }\n    `}const i=t[5],c=t[4]*i,u=t[3]*c,l=t[2]*u,d=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${l}, ${u}, ${c})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Ye(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],x=h[1];if(x===d&&null==p)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${c}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(x===i&&null==p)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const g=Ke(n);return`\n    float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${l} + depth * ${u} +\n          depth2 * ${c} + depth3 * ${i} + depth4 + ${g};\n      vec2 uv = uvFromFlat(${f}, ${x}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Me(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=se();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=se();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,s=o[0],i=o[1],c=se();if(null!=o&&Object(r.gb)(t,o))return`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${s}.0);\n\n        return ${c.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(t[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===t[0]){const n=[1,2],a=["b","row","col"];return`\n        ${Me(Qe(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Ze(a,n)});\n        }\n      `}const s=o[0],i=o[1],c=Math.ceil(t[2]/2),u=c*Math.ceil(t[1]/2),l=se();return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${s}, ${i}, ${u}, ${c}, b, row, col);\n      return ${l.texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],i=s[0],c=s[1],u=Math.ceil(t[n-1]/2);let l=u*Math.ceil(t[n-2]/2),d="int b, int row, int col",p=`b * ${l} + (row / 2) * ${u} + (col / 2)`;for(let e=2;e<n-1;e++)d=`int b${e}, `+d,l*=t[n-e-1],p=`b${e} * ${l} + `+p;const h=se();return`\n    vec4 ${a}(${d}) {\n      int index = ${p};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${i});\n      return ${h.texture2D}(${r}, uv);\n    }\n  `}(e)}}const Ue="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ge="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ze="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Xe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function He(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Ke(e){return`offset${e}`}function Ye(e){const t=e.name,n=Object(r.Ec)(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function qe(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Qe(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Ze(e,t){return t.map((t=>e[t])).join(", ")}function Je(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const a=e.logicalShape,o=t[n],s=o.shape;if(!Object(r.gb)(a,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${s} must match`);if(e.isUniform&&o.isUniform)return;const i=e.texShape,c=o.isUniform?null:o.texData.texShape;if(!Object(r.gb)(i,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${c} must match`)}))}function et(e){return(t,n,a,o,s)=>{const i=Object(r.oc)(t,n),c=i.length,u=Object(r.Xd)(i),l=Object(r.Ec)(i),d=Object(r.Zd)(s,l),p=t.length,h=n.length,f=Object(r.Xd)(t),x=Object(r.Xd)(n),g=Object(r.ae)(t,i),m=Object(r.ae)(n,i);if(g.length+m.length===0)for(let t=0;t<d.length;++t)d[t]=e(a[t%a.length],o[t%o.length]);else for(let t=0;t<d.length;++t){const n=Object(r.be)(t,c,u),s=n.slice(-p);g.forEach((e=>s[e]=0));const i=Object(r.ce)(s,p,f),l=n.slice(-h);m.forEach((e=>l[e]=0));const b=Object(r.ce)(l,h,x);d[t]=e(a[i],o[b])}return[d,i]}}const tt=et(((e,t)=>e+t));function nt(e){return(t,n,a)=>{const o=Object(r.Zd)(n,t.length);for(let n=0;n<t.length;++n)o[n]=e(t[n],a);return o}}const rt=nt((e=>Math.ceil(e)));const at=nt((e=>Math.exp(e))),ot=nt((e=>Math.expm1(e))),st=nt((e=>Math.floor(e)));const it=et(((e,t)=>e>t?1:0)),ct=et(((e,t)=>e<t?1:0));const ut=nt((e=>Math.log(e)));const lt=et(((e,t)=>Math.max(e,t))),dt=et(((e,t)=>Math.min(e,t))),pt=et(((e,t)=>e*t));const ht=et(((e,t)=>e!==t?1:0));const ft=nt((e=>1/Math.sqrt(e)));const xt=et(((e,t)=>{const n=e-t;return n*n}));const gt=et(((e,t)=>e-t));var mt=Object.freeze({__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:tt,bincountImpl:function(e,t,n,a,o){const s=Object(r.Ec)(a),i=Object(r.de)(o,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=o||(i[r]+=s>0?t[n]:1)}return i},bincountReduceImpl:function(e,t,n,a=!1){const o=e.shape[0],s=e.shape[1],i=Object(r.Yc)([o,n],t.dtype);for(let r=0;r<o;r++)for(let o=0;o<s;o++){const s=e.get(r,o);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(a?i.set(1,r,s):t.size>0?i.set(i.get(r,s)+t.get(r,o),r,s):i.set(i.get(r,s)+1,r,s))}return i},ceilImpl:rt,concatImpl:function(e,t,n,o){const s=Object(r.ee)(n,Object(r.Ec)(t));if(o&&"string"!==n){let t=0;e.forEach((e=>{const n=Object(r.Ec)(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const o="string"===n?Object(a.g)(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const a=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[a+t]=o[i++]}r+=e.shape[1]}))}return s},expImpl:at,expm1Impl:ot,floorImpl:st,gatherV2Impl:function(e,t,n){const a=Object(r.Yc)(n,e.dtype);for(let n=0;n<a.size;++n){const r=a.indexToLoc(n).slice(),o=r[0],s=r[2],i=t.locToIndex([o,s]);r[2]=t.values[i];const c=e.locToIndex(r);a.values[n]=e.values[c]}return a},greaterImpl:it,lessImpl:ct,linSpaceImpl:function(e,t,n){const a=(t-e)/(n-1),o=Object(r.de)(n,"float32");o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+a;return o},logImpl:ut,maxImpl:function(e,t,n,a){const o=Object(r.Zd)(a,Object(r.Ec)(n));for(let n=0;n<o.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];t>a&&(a=t)}o[n]=a}return o},maximumImpl:lt,minimumImpl:dt,multiplyImpl:pt,negImpl:function(e,t,n){const a=Object(r.fe)(-1,n);return pt([],t,a,e,n)},notEqualImpl:ht,prodImpl:function(e,t,n,a){const[o,s]=Object(r.ge)(e,a),i=Object(r.he)(t,"int32"),c=Object(r.de)(Object(r.Ec)(o),i),u=Object(r.Ec)(s);for(let e=0;e<c.length;++e){const t=e*u;let r=1;for(let e=0;e<u;++e)r*=n[t+e];c[e]=r}return{outVals:c,outShape:o,outDtype:i}},rangeImpl:function(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return Object(r.de)(0,a);const o=Math.abs(Math.ceil((t-e)/n)),s=Object(r.de)(o,a);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s},rsqrtImpl:ft,sliceImpl:function(e,t,n,o,s){const i=Object(r.ie)(o,t,n),c=Object(r.Ec)(n),u=Object(r.Xd)(o);if(i){const n=Object(r.je)(t,u);return"string"===s?e.slice(n,n+c):e.subarray(n,n+c)}const l="string"===s?Object(a.g)(e):e,d=Object(r.Yc)(o,s,l),p=Object(r.Yc)(n,s);for(let e=0;e<p.size;++e){const n=p.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));p.set(d.get(...r),...n)}return"string"===s?Object(a.b)(p.values):p.values},squaredDifferenceImpl:xt,stridedSliceImpl:function(e,t,n,a){const o=Object(r.Yc)(e,t.dtype);for(let e=0;e<o.size;e++){const r=o.indexToLoc(e),s=new Array(r.length);for(let e=0;e<s.length;e++)s[e]=r[e]*n[e]+a[e];o.set(t.get(...s),...r)}return o},subImpl:gt,tileImpl:function(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=Object(r.Yc)(n,e.dtype);for(let t=0;t<a.values.length;++t){const n=a.indexToLoc(t),r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=n[t]%e.shape[t];const o=e.locToIndex(r);a.values[t]=e.values[o]}return a},topKImpl:function(e,t,n,a,o){const s=t[t.length-1],[i,c]=[e.length/s,s],u=Object(r.Zd)(n,i*a),l=Object(r.Zd)("int32",i*a);for(let t=0;t<i;t++){const n=t*c,r=e.subarray(n,n+c),o=[];for(let e=0;e<r.length;e++)o.push({value:r[e],index:e});o.sort(((e,t)=>t.value-e.value));const s=t*a,i=u.subarray(s,s+a),d=l.subarray(s,s+a);for(let e=0;e<a;e++)i[e]=o[e].value,d[e]=o[e].index}const d=t.slice();return d[d.length-1]=a,[Object(r.Yc)(d,n,u),Object(r.Yc)(d,"int32",l)]},transposeImpl:function(e,t,n,a,o){const s=t.length,i=Object(r.Ec)(t),c=Object(r.Xd)(t),u=Object(r.Xd)(o),l=Object(r.Zd)(n,Object(r.Ec)(o));for(let t=0;t<i;++t){const n=Object(r.be)(t,s,c),o=new Array(n.length);for(let e=0;e<o.length;e++)o[e]=n[a[e]];l[Object(r.ce)(o,s,u)]=e[t]}return l},uniqueImpl:function(e,t,n,a){const o=Object(r.ke)(t,n)[0],s=[1,n[0],1];for(let e=0;e<o;e++)s[0]*=n[e];s[1]=n[o];for(let e=o+1;e<n.length;e++)s[2]*=n[e];const i={},c=new Int32Array(n[o]),u=new r.ec(s,a,e),l=[],d=1===s[0]&&1===s[2];for(let t=0;t<n[o];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(u.get(n,t,r));n=e.join(",")}if(void 0!==i[n])c[t]=i[n];else{const e=Object.keys(i).length;i[n]=e,c[t]=e,l.push(t)}}const p=s.slice();p[1]=Object.keys(i).length;const h=new r.ec(p,a);l.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(u.get(n,e,r),n,t,r)}));const f=n.slice();return f[o]=p[1],{outputValues:h.values,outputShape:f,indices:c}}});const{addImpl:bt,bincountImpl:Ct,bincountReduceImpl:$t,ceilImpl:vt,concatImpl:It,expImpl:Rt,expm1Impl:Ot,floorImpl:wt,gatherV2Impl:kt,greaterImpl:yt,lessImpl:Et,linSpaceImpl:Nt,logImpl:Tt,maxImpl:Ft,maximumImpl:At,minimumImpl:St,multiplyImpl:_t,negImpl:Lt,prodImpl:Dt,rangeImpl:Pt,rsqrtImpl:Bt,simpleAbsImpl:jt,sliceImpl:Wt,stridedSliceImpl:Vt,subImpl:Mt,tileImpl:Ut,topKImpl:Gt,transposeImpl:zt,uniqueImpl:Xt}=mt;function Ht(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Kt(e,t){return 1===t?[e]:Ht(e,t)}class Yt{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=Kt("rc",t),r=qe(t),a=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let a=e-2;a<e;a++)r+=`${n[a]} >= ${t[a]}`,a<e-1&&(r+="||");return r}(t,e,n),o=function(e,t,n,r){if(1===e)return"";const a=r.slice(-2);return`\n    int r = ${a[0]};\n    int c = ${a[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),s=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let a=0;a<=1;a++){let o=`${0===r?"r":"rp1"}, ${0===a?"c":"cp1"}`;for(let n=2;n<e;n++)o=`${t[t.length-1-n]},`+o;n.push(o)}return n}(n,t);if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${a}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}}class qt{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${ie(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${ce(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Qt{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=Jt(t,n),a=en(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=Zt(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[a].shift();return this.usedTextures[a].push(e),e}let s;return r===l.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===l.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===l.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===l.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===l.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const o=Jt(n,a),s=en(t,o,a);s in this.freeTextures||(this.freeTextures[s]=[]);const i=Zt(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,a),c=Object(r.Bf)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==c&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[s],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Zt(e,t,n,r,a){const o=function(e,t){switch(e){case l.PACKED_2X2_FLOAT32:return ke(t);case l.PACKED_2X2_FLOAT16:return Ee(t);case l.UNPACKED_FLOAT32:return $e(t);case l.UNPACKED_FLOAT16:return Ie(t);case l.PACKED_4X1_UNSIGNED_BYTE:return Oe(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let s;if(a){const[t,n]=h(e[0],e[1]);s=t*n}else{const[t,n]=d(e[0],e[1]);s=t*n}return s*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,o)}function Jt(e,t){if(e===u.UPLOAD)return l.PACKED_2X2_FLOAT32;if(e===u.RENDER||null==e)return function(e){return Object(r.Bf)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?l.PACKED_2X2_FLOAT32:l.UNPACKED_FLOAT32:e?l.PACKED_2X2_FLOAT16:l.UNPACKED_FLOAT16}(t);if(e===u.DOWNLOAD||e===u.PIXELS)return l.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function en(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class tn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const nn="return abs(x);",rn="return x;";class an{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class on{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=Kt("rc",t),r=qe(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),s=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${s}));\n      }\n    `}}const sn=r.fc,cn={};class un extends r.le{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!Object(r.Bf)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=i(Object(r.Bf)().getNumber("WEBGL_VERSION"));this.binaryCache=((t=Object(r.Bf)().getNumber("WEBGL_VERSION"))in cn||(cn[t]={}),cn[t]),this.gpgpu=new Be(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new Qt(this.gpgpu),this.numMBBeforeWarning=null==Object(r.Bf)().global.screen?1024:Object(r.Bf)().global.screen.height*Object(r.Bf)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new r.me(this,Object(r.ne)())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,t,n){if((Object(r.Bf)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(r.Bf)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:u.UPLOAD,refCount:1,complexParentRefCount:0}),a}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}decComplexRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.complexParentRefCount>0&&t.refCount--}}move(e,t,n,a){if(Object(r.Bf)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:u.UPLOAD,refCount:1,complexParentRefCount:0})}disposeIntermediateTensorInfo(e){const t=e.dataId;if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--,e.refCount<1&&this.disposeData(t)}}readSync(e){const t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:c,isPacked:u}=t;if(null!=i){let t;t=u?new an(c,rn):new tn(c,rn);const n=this.runWebGLProgram(t,[{dataId:e,shape:c,dtype:o}],o),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===o)return n;const l=null!=this.activeTimers;let d,p;if(l&&(d=Object(r.oe)()),"complex64"===o){const e=this.readSync(s.real.dataId),t=this.readSync(s.imag.dataId);p=Object(a.n)(e,t)}else p=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Object(r.oe)()-d),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:c,isPacked:u}=t;if(null!=s){let t;t=u?new an(o,rn):new tn(o,rn);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:i}],i),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(!Object(r.Bf)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(r.Bf)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,d,h=null;if("complex64"!==i&&Object(r.Bf)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);h=this.gpgpu.createBufferFromTexture(t.texture,...p(o))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(c.real.dataId),this.read(c.imag.dataId)]),t=e[0],n=e[1];d=Object(a.n)(t,n)}else if(null==h)d=this.getValuesFromTexture(e);else{const e=Object(r.Ec)(o);d=this.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=l&&this.disposeIntermediateTensorInfo(l);const f=this.convertAndCacheOnCPU(e,d),x=this.pendingRead.get(e);return this.pendingRead.delete(e),x.forEach((e=>e(f))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),f}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>Object(r.od)(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(r.Yc)(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!g(n)){if(Object(r.Bf)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),o=Object(r.Ec)(t);if(Object(r.Bf)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...p(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(n),a}const s=Object(r.Bf)().getBool("WEBGL_PACK")&&!0===a,i=s?U(t):t,c=s?new he(i):new pe(i),u=this.runWebGLProgram(c,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),d}async time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const o=Object(r.pd)(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=Object(r.pd)(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);i.kernelMs=Object(r.qd)(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Object(r.oe)(),endMs:null}}endTimer(e){return Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Object(r.oe)(),e)}async getQueryTime(e){if(Object(r.Bf)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){if(this.pendingDisposal.has(e))return;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(!this.texData.has(e))return;if(this.texData.get(e).complexParentRefCount>0)return void this.texData.get(e).refCount--;this.releaseGPUData(e);const{complexTensorInfos:t}=this.texData.get(e);null!=t&&(this.texData.get(t.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(t.real),this.texData.get(t.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(t.imag)),this.texData.delete(e)}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return Object(r.Bf)().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Object(r.ne)().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,t=128){const n=this.getCPUBackend();return Object(r.Bf)().getBool("IS_TEST")||this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&e.every((e=>null==this.texData.get(e.dataId).texture&&Object(r.Ec)(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Object(a.x)("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return sn(e.shape,t)}packedUnaryOp(e,t,n){const r=new an(e.shape,t);return this.compileAndRun(r,[e],n)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=jt(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(r.Bf)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,nn,e.dtype);const t=new tn(e.shape,nn);return this.compileAndRun(t,[e])}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Object(r.rd)(n[0])){const o=n.map((e=>Object(r.sd)(e)));a=this.write(o,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:a}=this.makeTensorInfo(e,t,n);return Object(r.ne)().makeTensorFromDataId(a,e,t,this)}unpackTensor(e){const t=new on(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Yt(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[V(e.shape),...M(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[V(t),...M(t)],o=new qt(a,n),s=this.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:a}=t,o=U(r);let s;s=n?new de(o):new le(o);return{dtype:a,shape:r,dataId:this.runWebGLProgram(s,[{shape:o,dtype:a,dataId:e}],a,null,!0).dataId}}runWebGLProgram(e,t,n,a,o=!1){const s=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(s.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===c.DENSE){const t=p(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===Object(r.Ec)(s.shape))return i.values=Object(r.Zd)(s.dtype,0),s;const u=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Object(r.Ec)(t.shape)<=Object(r.Bf)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!X(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const d={shape:s.shape,texData:i,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((e=>{const t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${n}_${t}`}));const a=e.userCode;let o=e.constructor.name;return o+="_"+r+"_"+a,o}(e,l,d),f=this.getAndSaveBinary(h,(()=>function(e,t,n,a){const o=t.userCode,s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),i=s.map((e=>e.shapeInfo)),c={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},u=We(s,c,o,t.packedInputs),l=e.createProgram(u);let d=null;const p=e.getUniformLocation(l,"NAN",!1);1===Object(r.Bf)().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(l,"INFINITY",!1));const h={};for(let n=0;n<t.variableNames.length;n++){const r=t.variableNames[n],a=!1;h[r]=e.getUniformLocation(l,r,a),h[`offset${r}`]=e.getUniformLocation(l,`offset${r}`,a)}return{program:t,source:u,webGLProgram:l,uniformLocations:h,inShapeInfos:i,outShapeInfo:c,infLoc:d,nanLoc:p}}(this.gpgpu,e,l,d))),x=null!=this.activeTimers;let g;if(x&&(g=this.startTimer()),function(e,t,n,a,o){Je(t.inShapeInfos,n),Je([t.outShapeInfo],[a]);const s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s,i[0],i[1]):e.setOutputMatrixTexture(s,i[0],i[1]),e.setProgram(t.webGLProgram),1===Object(r.Bf)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,a)=>{const o=t.program.variableNames[a],s=t.uniformLocations[o],i=t.uniformLocations[`offset${o}`];if(null!=s)if(n.isUniform)if(Object(r.Ec)(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,s,a)})),null!=o&&o(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,f,l,d,a),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),x&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)})),!Object(r.Bf)().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===o){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a,o=!1){n=n||t[0].dtype;const s=this.runWebGLProgram(e,t,n,a,o);return Object(r.ne)().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(r.Bf)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(r.M)((()=>{if(!Object(r.Bf)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(r.Bf)().getBool("DEBUG");Object(r.Bf)().set("DEBUG",!1);const t=this.abs(Object(r.G)(1e-8)).dataSync()[0];if(Object(r.Bf)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:o,texture:s,usage:i,isPacked:c}=t;if(null!=s)return;const l=null!=this.activeTimers;let d;l&&(d=Object(r.oe)());let p=t.texShape;if(null==p&&(p=G(n,c),t.texShape=p),null!=o){const e=U(n);let s,i=p[1],f=p[0];const x=o instanceof Uint8Array;c?([i,f]=h(p[0],p[1]),s=new xe(e,[f,i],x)):s=new fe(e,[f,i],x);const g=this.makeTensorInfo([f,i],a);this.texData.get(g.dataId).usage=x?u.PIXELS:u.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),i,f,o);const m=!0,b=this.runWebGLProgram(s,[g],a,null,m),C=this.texData.get(b.dataId);t.texture=C.texture,t.texShape=C.texShape,t.isPacked=C.isPacked,t.usage=C.usage,this.disposeIntermediateTensorInfo(g),this.texData.delete(b.dataId),t.values=null,l&&(this.uploadWaitMs+=Object(r.oe)()-d)}else{const e=this.acquireTexture(p,i,a,c);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Object(r.td)(t)}}Object(r.ud)()&&Object(r.vd)("webgl",(()=>new un),2);class ln{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Object(r.oc)(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class dn{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Object(r.oc)(t,n);const o=this.outputShape.length;let s="";if(a)if(0===o||1===Object(r.Ec)(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${qe(o)} coords = getOutputCoords();\n        `,1===o)s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Kt("coords",o);s+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function pn(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const hn={kernelName:r.wd,backendName:"webgl",kernelFunc:pn};function fn(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,o=n.makeTensorInfo(r.shape,"complex64"),s=n.texData.get(o.dataId),i=pn({inputs:{x:r},backend:n});n.texData.get(i.dataId).complexParentRefCount++;const c=pn({inputs:{x:a},backend:n});return n.texData.get(c.dataId).complexParentRefCount++,s.complexTensorInfos={real:i,imag:c},o}const xn={kernelName:r.xd,backendName:"webgl",kernelFunc:fn},gn="return (a < 0.) ? b * a : a;",mn="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const bn={kernelName:r.yd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{alpha:s}=a,i=n.makeTensorInfo([],"float32",Object(r.fe)(s,"float32")),c=Object(r.Bf)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dn(mn,o.shape,i.shape):new ln(gn,o.shape,i.shape),u=n.runWebGLProgram(c,[o,i],o.dtype);return n.disposeIntermediateTensorInfo(i),u}},Cn="return (a < 0.) ? b * a : a;",$n="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const vn={kernelName:r.zd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:o}=t,s=Object(r.Bf)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dn($n,a.shape,o.shape):new ln(Cn,a.shape,o.shape);return n.runWebGLProgram(s,[a,o],a.dtype)}};function In({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:o,backend:s})=>{const{x:i}=o,c=s,u=a||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=n){const e=c.texData.get(i.dataId),t=n(e.values,u);return c.makeTensorInfo(i.shape,u,t)}let l;return l=Object(r.Bf)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new an(i.shape,t):new tn(i.shape,e),c.runWebGLProgram(l,[i],u)}}function Rn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:c})=>{const{a:u,b:l}=i,d=c;if(a&&"complex64"===u.dtype){const t=d.texData.get(u.dataId),n=d.texData.get(l.dataId),[a,o]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,a]=t,o={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:a.dataId,dtype:a.dtype,shape:l.shape},i=new ln(e,u.shape,l.shape);return d.runWebGLProgram(i,[o,s],Object(r.he)(n.dtype,a.dtype))})),s=fn({inputs:{real:a,imag:o},backend:d});return d.disposeIntermediateTensorInfo(a),d.disposeIntermediateTensorInfo(o),s}const p=s||Object(r.he)(u.dtype,l.dtype);if(d.shouldExecuteOnCPU([u,l])&&null!=o){const e=d.texData.get(u.dataId),t=d.texData.get(l.dataId),[n,r]=o(u.shape,l.shape,e.values,t.values,p),a=d.makeTensorInfo(r,p);return d.texData.get(a.dataId).values=n,a}let h;return h=Object(r.Bf)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new dn(t,u.shape,l.shape,n):new ln(e,u.shape,l.shape),d.runWebGLProgram(h,[u,l],p)}}function On(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?$n:Cn;if("leakyrelu"===e)return t?mn:gn;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class wn{constructor(e,t,n,r=!1,a=!1,o=!1,s=null,i=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=r?e[1]:e[2],l=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",g="";s&&(x=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,g="result = activation(result);");const m=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",C="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(C=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${x}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${b};\n          int batchB = ${C};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${m}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const kn="return areal * breal - aimag * bimag;",yn="return areal * bimag + aimag * breal;";class En{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Object(r.oc)(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Nn="return a * b;";function Tn(e){const{inputs:t,backend:n}=e,{a:a,b:o}=t,s=Object(r.he)(a.dtype,o.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(o.dataId),r=new En(kn,a.shape,o.shape),s=new En(yn,a.shape,o.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape}],c=n.runWebGLProgram(r,i,"float32"),u=n.runWebGLProgram(s,i,"float32"),l=fn({inputs:{real:c,imag:u},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),l}if(n.shouldExecuteOnCPU([a,o])){const e=n.texData.get(a.dataId),t=n.texData.get(o.dataId),[r,i]=_t(a.shape,o.shape,e.values,t.values,s),c=n.makeTensorInfo(i,s);return n.texData.get(c.dataId).values=r,c}let i;return i=Object(r.Bf)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dn(Nn,a.shape,o.shape):new ln(Nn,a.shape,o.shape),n.runWebGLProgram(i,[a,o],s)}const Fn={kernelName:r.Ad,backendName:"webgl",kernelFunc:Tn};function An(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{shape:s}=a,i=n,c=Object(r.Ec)(o.shape),u=Object(r.Cd)(s,c),l=Object(r.Ec)(u);Object(r.F)(c===l,(()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${c} elements. The new shape and old shape must have the same number of elements.`));const d=i.texData.get(o.dataId);return!d.isPacked||X(o.shape,u)||null!==d.texture&&X(d.shape,u)?(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype}):function(e,t,n){const r=[V(e.shape),...M(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},o=[V(t),...M(t)],s=new qt(o,r),i=n.runWebGLProgram(s,[a],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}(o,u,i)}const Sn={kernelName:r.Bd,backendName:"webgl",kernelFunc:An};class _n{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:o,outSize:s}=e;this.outputShape=[a,s];const i=4*Math.floor(n/4),c=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${Object(r.Tc)(e)?e.toPrecision(2):e}, ones);`}let l="";o%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===c}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Ln{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const u=4*Math.floor(n/4),l=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,p="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===l}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===l}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===l}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${c});\n      }\n    `}}function Dn(e,t,n,r){const o=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Object(a.d)(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let a=0;a<o.length;a++){const{inSize:i,windowSize:c,outSize:u}=o[a];let l,d;l="mean"===n?0===a?new _n({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u},i):new _n({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u}):new Ln({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(l,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class Pn{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=qe(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class Bn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=qe(this.rank),a=Ht("rc",this.rank),o=new Array(this.rank);for(let e=0;e<t.length;e++)o[t[e]]=a[e];const s=`vec2(${o.slice(-2).join()})`,i=`++${a[this.rank-1]} < ${n[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${i}) {\n        result[1] = ${c};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${c};\n        if(${i}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function jn(e,t,n){const a=Object(r.Bf)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bn(e.shape,t):new Pn(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function Wn(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s,keepDims:i}=a;return function(e,t,n,a){const o=t,s=e.shape.length,i=Object(r.ke)(o,e.shape);let c=i;const u=Object(r.Dd)(c,s),l=null!=u;let d=e;l&&(d=jn(e,u,a),c=Object(r.Ed)(c.length,s)),Object(r.Fd)("sum",c,s);const[p,h]=Object(r.ge)(d.shape,c);let f=p;n&&(f=Object(r.Pd)(p,i));const x=Object(r.Ec)(h),g=An({inputs:{x:d},attrs:{shape:[Object(r.Ec)(e.shape)/x,x]},backend:a}),m=Dn(g,Object(r.Gd)(e.dtype),"sum",a),b=An({inputs:{x:m},attrs:{shape:f},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(m),l&&a.disposeIntermediateTensorInfo(d),b}(o,s,i,n)}const Vn={kernelName:r.Hd,backendName:"webgl",kernelFunc:Wn};function Mn(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:o}=r,s=n,i=a.shape.length,c=new Array(i);for(let e=0;e<c.length;e++)c[e]=a.shape[o[e]];let u;if(s.shouldExecuteOnCPU([a])){const e=s.texData.get(a.dataId).values,t=zt(e,a.shape,a.dtype,o,c);u=s.makeTensorInfo(c,a.dtype);s.texData.get(u.dataId).values=t}else u=jn(a,o,s);return u}const Un={kernelName:r.Id,backendName:"webgl",kernelFunc:Mn};function Gn({a:e,b:t,transposeA:n,transposeB:a,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:u=null}){const l=e.shape.length,d=t.shape.length,p=n?e.shape[l-2]:e.shape[l-1],h=a?t.shape[d-1]:t.shape[d-2],f=n?e.shape[l-1]:e.shape[l-2],x=a?t.shape[d-2]:t.shape[d-1],g=e.shape.slice(0,-2),m=t.shape.slice(0,-2),b=Object(r.Ec)(g),C=Object(r.Ec)(m),$=b===C||1===b||1===C;Object(r.F)(l>=2&&d>=2&&$,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${g}) and (${m}).`));const v=(b>C?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([f,x]);Object(r.F)(p===h,(()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`));const I=n?[b,p,f]:[b,f,p],R=a?[C,x,h]:[C,h,x],O=An({inputs:{x:e},backend:o,attrs:{shape:I}}),w=An({inputs:{x:t},backend:o,attrs:{shape:R}}),k=[O,w],y=Math.max(b,C),E=n?O.shape[1]:O.shape[2],N=null!=s,T=null!=i,F="leakyrelu"===u,A=null!=u?On(u,!0):null;let S;if((1===f||1===x)&&E>1e3&&!1===(N||T||F||null!=A)){let e=O,t=w;n&&(e=Mn({inputs:{x:O},backend:o,attrs:{perm:[0,2,1]}}),k.push(e)),a&&(t=Mn({inputs:{x:w},backend:o,attrs:{perm:[0,2,1]}}),k.push(t));const r=1===x;let s=e;1!==x&&(s=An({inputs:{x:e},backend:o,attrs:{shape:[y,E,1]}}),k.push(s));const i=1===x?2:1;let c=t;r&&(c=An({inputs:{x:t},backend:o,attrs:{shape:[y,1,E]}}),k.push(c));const u=Tn({inputs:{a:s,b:c},backend:o});S=Wn({inputs:{x:u},backend:o,attrs:{axis:i,keepDims:!0}}),k.push(u)}else{const u=Object(r.he)(e.dtype,t.dtype),l=new wn(I,R,[y,f,x],n,a,N,A,T,F),d=[O,w];if(null!=s&&d.push(s),T&&d.push(i),F){const e=o.makeTensorInfo([],"float32",Object(r.fe)(c,"float32"));d.push(e),k.push(e)}S=o.runWebGLProgram(l,d,u)}const _=An({inputs:{x:S},backend:o,attrs:{shape:v}});k.push(S);for(const e of k)o.disposeIntermediateTensorInfo(e);return _}const zn={kernelName:r.zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o,bias:s,preluActivationWeights:i}=t,{transposeA:c,transposeB:u,activation:l,leakyreluAlpha:d}=r;return Gn({a:a,b:o,transposeA:c,transposeB:u,backend:n,bias:s,preluActivationWeights:i,leakyreluAlpha:d,activation:l})}},Xn="return abs(x);";const Hn={kernelName:r.Jd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=jt(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let o;return o=Object(r.Bf)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new an(a.shape,Xn):new tn(a.shape,Xn),n.runWebGLProgram(o,[a],a.dtype)}},Kn=In({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Yn={kernelName:r.Kd,backendName:"webgl",kernelFunc:Kn},qn=In({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Qn={kernelName:r.Ld,backendName:"webgl",kernelFunc:qn},Zn="return a + b;",Jn=Rn({opSnippet:Zn,packedOpSnippet:Zn,supportsComplex:!0,cpuKernelImpl:bt}),er={kernelName:r.Md,backendName:"webgl",kernelFunc:Jn};class tr{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class nr{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const rr={kernelName:r.Qc,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,o=n;if(1===o.length)return pn({inputs:{x:o[0]},backend:a});if(o.length>Object(r.Bf)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(o.length/2),n=e({inputs:o.slice(0,t),backend:a}),r=e({inputs:o.slice(t),backend:a});return e({inputs:[n,r],backend:a})}const s=o.map((e=>e.dtype)).reduce(((e,t)=>Object(r.he)(e,t))),i=o.map((e=>e.shape)),c=Object(r.Bf)().getBool("WEBGL_PACK")?new nr(o[0].shape,i):new tr(o[0].shape,i);return a.runWebGLProgram(c,o,s)}};const ar={kernelName:r.Nd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s,keepDims:i}=a,c=o.shape.length,u=Object(r.ke)(s,o.shape);let l=u;const d=Object(r.Dd)(l,c);let p=o;null!=d&&(p=Mn({inputs:{x:o},backend:n,attrs:{perm:d}}),l=Object(r.Ed)(l.length,c)),Object(r.Fd)("all",l,c);const[h,f]=Object(r.ge)(p.shape,l),x=An({inputs:{x:p},backend:n,attrs:{shape:[-1,Object(r.Ec)(f)]}}),g=Dn(x,x.dtype,"all",n);let m;if(i){m=An({inputs:{x:g},backend:n,attrs:{shape:Object(r.Pd)(h,u)}})}else m=An({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(p),m}};const or={kernelName:r.Od,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s,keepDims:i}=a,c=o.shape.length,u=Object(r.ke)(s,o.shape);let l=u;const d=Object(r.Dd)(l,c);let p=o;null!=d&&(p=Mn({inputs:{x:o},backend:n,attrs:{perm:d}}),l=Object(r.Ed)(l.length,c)),Object(r.Fd)("any",l,c);const[h,f]=Object(r.ge)(p.shape,l),x=An({inputs:{x:p},backend:n,attrs:{shape:[-1,Object(r.Ec)(f)]}}),g=Dn(x,x.dtype,"any",n);let m;if(i){m=An({inputs:{x:g},backend:n,attrs:{shape:Object(r.Pd)(h,u)}})}else m=An({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(p),m}};class sr{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const s="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class ir{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Object(r.F)(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const o=e[e.length-1],s=Math.ceil(o/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");const i=this.outputShape,c=i.length,u=qe(c),l=Kt("coords",c);let d,p;if(1===s){p=c+1;const e=qe(p);d=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[c-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[c-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[c-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[c-2]};`}else p=c,d=`\n        ${u} sourceLocR = coords;\n        ++${l[c-1]};\n        ${u} sourceLocG = coords;\n        ++${l[c-2]};\n        ${u} sourceLocA = coords;\n        --${l[c-1]};\n        ${u} sourceLocB = coords;\n        --${l[c-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],x=h.map((e=>"int "+e)),g=Kt("sourceLocR",p-1).concat("inIdx.r"),m=Kt("sourceLocG",p-1).concat("inIdx.g"),b=Kt("sourceLocB",p-1).concat("inIdx.b"),C=Kt("sourceLocA",p-1).concat("inIdx.a"),$="max"===n?"greaterThan":"lessThan",v=a?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${C.join()})));`,I=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,R=a?"":`\n      float getBestIndicesAChannel(${x.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${x.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${R}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[c-1]} < ${i[c-1]-1};\n        bool hasNextRow = ${l[c-2]} < ${i[c-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function cr(e,t,n,r=null){let o=t.shape[0],s=t.shape[1];null!=r&&(o=r.shape[0],s=r.shape[1]);const i=Object(a.d)(s),c={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new sr(c,n,null==r),l=[t];null!=r&&l.push(r);const d=e.runWebGLProgram(u,l,"int32");if(1===d.shape[1])return d;const p=cr(e,t,n,d);return e.disposeIntermediateTensorInfo(d),p}function ur(e,t,n,r=null){const o=null!=r?r.shape:t.shape,s=o[o.length-1],i=Object(a.d)(s),c=new ir(o,i,n,null==r),u=null==r?[t]:[t,r],l=e.runWebGLProgram(c,u,"int32");if(l.shape.length===t.shape.length){const r=ur(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function lr(e,t,n,a){const o=[n];if(Object(r.Fd)("arg"+a.charAt(0).toUpperCase()+a.slice(1),o,t.shape.length),!Object(r.Bf)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[s,i]=Object(r.ge)(t.shape,o),c=Object(r.Ec)(i),u=An({inputs:{x:t},backend:e,attrs:{shape:[-1,c]}});n.push(u);const l=cr(e,u,a);n.push(l);const d=An({inputs:{x:l},backend:e,attrs:{shape:s}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return ur(e,t,a)}const dr={kernelName:r.dd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s}=a;let i=Object(r.ke)(s,o.shape);const c=Object(r.Dd)(i,o.shape.length);let u=o;const l=[];null!=c&&(u=Mn({inputs:{x:o},backend:n,attrs:{perm:c}}),l.push(u),i=Object(r.Ed)(i.length,u.shape.length)),Object(r.Fd)("argMax",[i[0]],u.shape.length);const d=lr(n,u,i[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const pr={kernelName:r.re,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s}=a;let i=Object(r.ke)(s,o.shape);const c=Object(r.Dd)(i,o.shape.length);let u=o;const l=[];null!=c&&(u=Mn({inputs:{x:o},backend:n,attrs:{perm:c}}),l.push(u),i=Object(r.Ed)(i.length,u.shape.length)),Object(r.Fd)("argMin",[i[0]],u.shape.length);const d=lr(n,u,i[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},hr=In({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),fr={kernelName:r.se,backendName:"webgl",kernelFunc:hr},xr=In({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),gr={kernelName:r.te,backendName:"webgl",kernelFunc:xr},mr=In({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),br={kernelName:r.ue,backendName:"webgl",kernelFunc:mr},Cr=Rn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),$r={kernelName:r.ve,backendName:"webgl",kernelFunc:Cr},vr=In({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Ir={kernelName:r.we,backendName:"webgl",kernelFunc:vr};class Rr{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let m="0.0";if(f||(m="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?x:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const C=4*Math.floor(o/4),$=o%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${C};\n          if (${1===$}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===$}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===$}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class Or{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,g=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let C="0.0";if(b||(C="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${i}, ${c});\n        const ivec3 pads = ivec3(${x}, ${g}, ${m});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let $=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&($="avgValue / count");const v=4*Math.floor(o/4),I=o%4,R=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${i}, ${c});\n      const ivec3 pads = ivec3(${x}, ${g}, ${m});\n      const float initializationValue = ${C};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${C});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${R}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${R}\n            }\n          }\n          setOutput(${$});\n        }\n      }\n    `}}const wr={kernelName:r.xe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t;ae(o,"avgPool");const{filterSize:s,strides:i,pad:c,dimRoundingMode:u}=a;Object(r.F)(Object(r.Sc)(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=Object(r.ye)(o.shape,s,i,1,c,u);if(1===l.filterWidth&&1===l.filterHeight&&Object(r.gb)(l.inShape,l.outShape))return pn({inputs:{x:o},backend:n});const d=new Rr(l,"avg",!1);return n.runWebGLProgram(d,[o],"float32")}};const kr={kernelName:r.Uc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{filterSize:s,strides:i,pad:c,dimRoundingMode:u,dataFormat:l}=a,d=Object(r.ze)(o.shape,s,i,[1,1,1],c,u,l),p=new Or(d,"avg",!1);return n.runWebGLProgram(p,[o],"float32")}};class yr{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=i-1-e.padInfo.top,l=c-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${l});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${s}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Er{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=d-1-e.padInfo.top,x=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${x});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Nr={kernelName:r.Ae,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,input:s}=t,i=s,{filterSize:c,strides:u,pad:l,dimRoundingMode:d}=a,p=Object(r.ze)(i.shape,c,u,[1,1,1],l,d),h=new Er(p);return n.runWebGLProgram(h,[o],i.dtype)}};const Tr={kernelName:r.cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,input:s}=t,i=s;ae([o,s],"avgPoolGrad");const{filterSize:c,strides:u,pad:l}=a,d=Object(r.ye)(i.shape,c,u,1,l),p=new yr(d);return n.runWebGLProgram(p,[o],i.dtype)}};const Fr={kernelName:r.df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o}=t,{transposeA:s,transposeB:i}=r;return Gn({a:a,b:o,transposeA:s,transposeB:i,backend:n})}};class Ar{constructor(e,t,n,a,o,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Object(r.oc)(e,t),Object(r.oc)(e,n);let i="0.0";null!=a&&(Object(r.oc)(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let c="1.0";null!=o&&(Object(r.oc)(e,o),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${c};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Sr{constructor(e,t,n,a,o,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Object(r.oc)(e,t),Object(r.oc)(e,n);let i="vec4(0.0)";null!=a&&(Object(r.oc)(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let c="vec4(1.0)";null!=o&&(Object(r.oc)(e,o),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${c};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const _r={kernelName:r.ef,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,mean:o,variance:s,offset:i,scale:c}=e;Object(r.F)(o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Object(r.F)(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Object(r.F)(null==c||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[a,o,s];let d=null;null!=i&&(d=i.shape,l.push(i));let p=null;null!=c&&(p=c.shape,l.push(c));const h=Object(r.Bf)().getBool("WEBGL_PACK_NORMALIZATION")?new Sr(a.shape,o.shape,s.shape,d,p,u):new Ar(a.shape,o.shape,s.shape,d,p,u);return t.runWebGLProgram(h,l,l[0].dtype)}};class Lr{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=qe(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return Dr.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let a;a=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Dr[t]} = start[${t}] + coords.${Dr[t]};`)).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${a}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const Dr=["x","y","z","w","u","v"];class Pr{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=qe(this.rank),n=Kt("coords",this.rank),r=Kt("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${a})`,s=`\n      result.x = ${o};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${s}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function Br(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{begin:s,size:i}=a,[c,u]=Object(r.gf)(o,s,i);if(Object(r.hf)(o,c,u),0===Object(r.Ec)(u))return n.makeTensorInfo(u,o.dtype,[]);if(n.shouldExecuteOnCPU([o])||"string"===o.dtype){const e=n.texData.get(o.dataId),t=Wt(e.values,c,u,o.shape,o.dtype);return n.makeTensorInfo(u,o.dtype,t)}const{isPacked:l}=n.texData.get(o.dataId),d=Object(r.ie)(o.shape,c,u);if(l||!d){const e=Object(r.Bf)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pr(u):new Lr(u),t=e.getCustomSetupFunc(c);return n.runWebGLProgram(e,[o],o.dtype,t)}return n.uploadToGPU(o.dataId),function(e,t,n,a){const o=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,o),i.complexParentRefCount=0,i.refCount=1,i.shape=n,i.dtype=e.dtype;let c=Object(r.je)(t,Object(r.Xd)(e.shape));o.slice&&(c+=o.slice.flatOffset),i.slice={flatOffset:c,origDataId:o.slice&&o.slice.origDataId||e.dataId};const u=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,u+1),s}(o,c,u,n)}const jr={kernelName:r.ff,backendName:"webgl",kernelFunc:Br},Wr={kernelName:r.if,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{x:s}=t,{blockShape:i,crops:c}=o;Object(r.F)(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const u=i.reduce(((e,t)=>e*t)),l=Object(a.h)(s.shape,i,u),d=Object(a.e)(l.length,i.length),p=Object(a.f)(s.shape,i,u),h=Object(a.i)(c,i.length),f=Object(a.j)(p,c,i.length),x=[],g=An({inputs:{x:s},backend:n,attrs:{shape:l}}),m=Mn({inputs:{x:g},backend:n,attrs:{perm:d}}),b=An({inputs:{x:m},backend:n,attrs:{shape:p}}),C=Br({inputs:{x:b},backend:n,attrs:{begin:h,size:f}});return x.push(g),x.push(m),x.push(b),x.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};const Vr={kernelName:r.Vc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:s}=r,i=n.readSync(a.dataId),c=n.readSync(o.dataId),u=Ct(i,c,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,u)}},Mr=Rn({opSnippet:"return float(a != b);",dtype:"bool"}),Ur={kernelName:r.jf,backendName:"webgl",kernelFunc:Mr};function Gr(e){const{inputs:t,backend:n}=e,{input:r}=t;return pn({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const zr={kernelName:r.kf,backendName:"webgl",kernelFunc:Gr};const Xr={kernelName:r.lf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:o}=t,{x:s}=n,{dtype:i}=o;if("complex64"===i){if("complex64"===s.dtype)return pn({inputs:{x:s},backend:a});const t=Object(r.yb)(s.shape),n=e({inputs:{x:s},backend:a,attrs:{dtype:"float32"}}),o=fn({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),o}if("complex64"===s.dtype){const t=Gr({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:i}});return a.disposeIntermediateTensorInfo(t),n}if(!Object(r.mf)(s.dtype,i)){const e=pn({inputs:{x:s},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i)return function(e,t){const n=new tn(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,a);if("bool"===i){const e=a.makeTensorInfo([],"bool",Object(r.Zd)("bool",1)),t=Mr({inputs:{a:s,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},Hr="return ceil(x);",Kr=In({opSnippet:Hr,packedOpSnippet:Hr,cpuKernelImpl:vt}),Yr={kernelName:r.nf,backendName:"webgl",kernelFunc:Kr};class qr{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class Qr{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const Zr={kernelName:r.of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{clipValueMin:s,clipValueMax:i}=a;let c;c=Object(r.Bf)().getBool("WEBGL_PACK_CLIP")?new Qr(o.shape):new qr(o.shape);const u=c.getCustomSetupFunc(s,i);return n.runWebGLProgram(c,[o],o.dtype,u)}};class Jr{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function ea(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const ta={kernelName:r.pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),o=new Jr(r.shape),s=[ea(r,a.complexTensorInfos.real),ea(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(o,s,s[0].dtype)}};class na{constructor(e){this.outputShape=[],this.outputShape=Object(a.k)(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,o=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ra{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Object(a.k)(e,t);const n=this.outputShape,r=n.length,o=qe(r),s=Kt("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const c=new Array(e.length-1);c[0]=e[0][t];for(let n=1;n<c.length;n++)c[n]=c[n-1]+e[n][t];const u=i[t],l=i.slice(-2),d=i.join();let p=`if (${u} < ${c[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${l.join()}));\n        }`;for(let e=1;e<c.length;e++){const t=c[e-1];p+=`\n        if (${u} < ${c[e]}  && ${u} >= ${c[e-1]}) {\n          return getChannel(\n            getT${e}(${aa(i,u,t)}),\n            vec2(${aa(l,u,t)}));\n        }`}const h=c.length,f=c[c.length-1];p+=`\n        return getChannel(\n          getT${h}(${aa(i,u,f)}),\n          vec2(${aa(l,u,f)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${p}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function aa(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function oa(e){const{inputs:t,backend:n}=e,{input:r}=t;return pn({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const sa={kernelName:r.qf,backendName:"webgl",kernelFunc:oa};function ia(e,t,n){const o=e[0].dtype;if("complex64"===o){const r=e.map((e=>Gr({inputs:{input:e},backend:n}))),a=e.map((e=>oa({inputs:{input:e},backend:n}))),o=ia(r,t,n),s=ia(a,t,n),i=fn({inputs:{real:o,imag:s},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),i}if("string"===o){const{tensors2D:r,outShape:s}=ca(e,t,n),i=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),c=1===r[0].shape[0],u=It(i,s,o,c),l=Object(a.k)(e.map((e=>e.shape)),t),d=n.makeTensorInfo(l,o,u);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}if(e.length>Object(r.Bf)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),a=ia(e.slice(0,r),t,n),o=ia(e.slice(r),t,n),s=ia([a,o],t,n);return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),s}if(Object(r.Bf)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new ra(e.map((e=>e.shape)),t);return n.runWebGLProgram(r,e,o)}const{tensors2D:s,outShape:i}=ca(e,t,n),c=new na(s.map((e=>e.shape))),u=n.runWebGLProgram(c,s,o);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));const l=An({inputs:{x:u},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(u),l}function ca(e,t,n){const o=Object(a.k)(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>An({inputs:{x:e},attrs:{shape:[-1,Object(r.Ec)(e.shape.slice(t))]},backend:n}))),outShape:o}}function ua(e){const{inputs:t,backend:n,attrs:o}=e,{axis:s}=o,i=Object(r.ke)(s,t[0].shape)[0],c=Object(a.k)(t.map((e=>e.shape)),i);if(0===Object(r.Ec)(c))return n.makeTensorInfo(c,t[0].dtype,[]);const u=t.filter((e=>Object(r.Ec)(e.shape)>0));if(1===u.length)return pn({inputs:{x:u[0]},backend:n});const l=u.map((e=>e.shape));return Object(a.l)(l,i),ia(u,i,n)}const la={kernelName:r.rf,backendName:"webgl",kernelFunc:ua};class da{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,x="channelsLast"===e.dataFormat,g=x?1:2,m=x?2:3,b=x?3:1;let C="",$="";n&&(C=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,$="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${C}\n\n      const ivec2 strides = ivec2(${i}, ${c});\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${m}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${x}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${x}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${x}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${x}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${$}\n        setOutput(result);\n      }\n    `}}class pa{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,l=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${o}, ${s});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${l}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ha{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:a,strideWidth:o,strideHeight:s,padInfo:i,outWidth:c,dilationWidth:u,dilationHeight:l,dataFormat:d}=n,{left:p,top:h}=i,f=a*r,x=se(),g="channelsLast"===d,m=g?0:1,b=g?1:2;let C="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)C+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${c})) * ${s} - ${h};\n            d0 = offsetY + ${l} * (pos / ${f});\n\n            if(d0 < ${t[m]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${c}.) * ${o}. - ${p}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${a}.));\n\n              if(d1 < ${t[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${a}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${C}\n\n        ${x.output} = result;\n      }\n    `}}function fa({x:e,filter:t,convInfo:n,backend:a,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}){const u=e.shape,l=a.texData.get(e.dataId),d=n.inChannels,p=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat;let x;const g=[],m=(1===p||1===h)&&d>1e3,b=u[2]%2!=0&&!!l.isPacked;if(!m&&Object(r.Bf)().getBool("WEBGL_LAZILY_UNPACK")&&Object(r.Bf)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&b){const d=f?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),p={dataId:e.dataId,shape:[1,d,n.inChannels],dtype:e.dtype},h=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Object(r.F)(X(l.shape,p.shape),(()=>`packed reshape ${l.shape} to ${p.shape} isn't free`));const m=An({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(m);const b=Gn({a:p,b:m,backend:a,transposeA:false,transposeB:false,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i}),C=a.texData.get(b.dataId);Object(r.F)(C.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=h,C.shape=n.outShape,x=pn({inputs:{x:b},backend:a}),x.shape=n.outShape,g.push(b)}else{const r=An({inputs:{x:e},backend:a,attrs:{shape:[1,f?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),l=An({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=Gn({a:r,b:l,transposeA:false,transposeB:false,backend:a,bias:o,activation:c,preluActivationWeights:s,leakyreluAlpha:i});x=An({inputs:{x:d},backend:a,attrs:{shape:n.outShape}}),g.push(r),g.push(l),g.push(d)}for(const e of g)a.disposeIntermediateTensorInfo(e);return x}function xa({x:e,filter:t,convInfo:n,backend:a,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:c=null}){const{filterWidth:u,filterHeight:l,inChannels:d,outWidth:p,outHeight:h,dataFormat:f}=n,x="channelsLast"===f,g=u*l*d,m=h*p,b=[g,m],C=[],$=An({inputs:{x:e},backend:a,attrs:{shape:e.shape.slice(1)}}),v=An({inputs:{x:t},backend:a,attrs:{shape:[1,g,Object(r.Ec)(t.shape)/g]}});C.push($),C.push(v);const I=new ha(b,$.shape,n),R=a.runWebGLProgram(I,[$],"float32"),O=An({inputs:{x:R},backend:a,attrs:{shape:[1,b[0],b[1]]}});C.push(R),C.push(O);const w=null!=o,k=null!=s,y="leakyrelu"===c,E=c?On(c,!0):null,N=new wn(O.shape,v.shape,[1,m,n.outChannels],!0,!1,w,E,k,y),T=[O,v];if(o&&T.push(o),k&&T.push(s),y){const e=a.makeTensorInfo([],"float32",Object(r.fe)(i,"float32"));T.push(e),C.push(e)}const F=a.runWebGLProgram(N,T,"float32"),A=An({inputs:{x:F},backend:a,attrs:{shape:x?[1,h,p,n.outChannels]:[1,n.outChannels,h,p]}});C.push(F);for(const e of C)a.disposeIntermediateTensorInfo(e);return A}const ga={kernelName:r.sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,filter:s}=t,{strides:i,pad:c,dataFormat:u,dilations:l,dimRoundingMode:d}=a,p=Object(r.tf)(u),h=Object(r.mc)(o.shape,s.shape,i,l,c,d,!1,p);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(Object(r.Bf)().getBool("WEBGL_CONV_IM2COL")&&1===o.shape[0])f=xa({x:o,filter:s,convInfo:h,backend:n});else{const e=new da(h);f=n.runWebGLProgram(e,[o,s],"float32")}else f=fa({x:o,filter:s,convInfo:h,backend:n});const x=An({inputs:{x:f},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(f),x}};class ma{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${o}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ba{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=o?1:2,u=o?2:3,l=o?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${l}];\n\n        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ca{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${o};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${s};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $a{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${c}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const va={kernelName:r.uf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,dy:s}=t,{strides:i,pad:c,dataFormat:u,dimRoundingMode:l,filterShape:d}=a,p=Object(r.tf)(u),h=Object(r.mc)(o.shape,d,i,1,c,l,!1,p),f=new ma(h);return n.runWebGLProgram(f,[o,s],"float32")}};const Ia={kernelName:r.vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,filter:s}=t,{inputShape:i,strides:c,pad:u,dataFormat:l,dimRoundingMode:d}=a,p=Object(r.tf)(l),h=Object(r.mc)(i,s.shape,c,1,u,d,!1,p),f=new ba(h);return n.runWebGLProgram(f,[o,s],"float32")}};const Ra={kernelName:r.Wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,filter:s}=t,{strides:i,pad:c,dilations:u}=a,l=Object(r.wf)(o.shape,s.shape,i,u,c),d=new pa(l);return n.runWebGLProgram(d,[o,s],"float32")}};const Oa={kernelName:r.xf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,dy:s}=t,{strides:i,pad:c,filterShape:u}=a,l=Object(r.wf)(o.shape,u,i,1,c),d=new Ca(l);return n.runWebGLProgram(d,[o,s],"float32")}};const wa={kernelName:r.yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,filter:s}=t,{pad:i,strides:c,inputShape:u}=a,l=Object(r.wf)(u,s.shape,c,1,i),d=new $a(l);return n.runWebGLProgram(d,[o,s],"float32")}},ka=In({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),ya={kernelName:r.zf,backendName:"webgl",kernelFunc:ka},Ea=In({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Na={kernelName:r.Af,backendName:"webgl",kernelFunc:Ea};class Ta{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,c]=e,[u]=t,[l,d]=n;this.outputShape=[u,l,d,c];const p="bilinear"===r?1:0,[h,f]=[s-1+".0",i-1+".0"],[x,g,m]=l>1?[""+(s-1)/(l-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,C,$]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${x});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${C};\n\n        float in_y = ${m};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${$};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Fa={kernelName:r.Ac,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:o,boxInd:s}=t,{cropSize:i,method:c,extrapolationValue:u}=r,l=new Ta(a.shape,o.shape,i,c,u);return n.runWebGLProgram(l,[a,o,s],"float32")}};class Aa{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,a=t?"0.0":`getX(${Sa(r,"coords")})`,o=e[e.length-1];let s="",i="";t?(s=n?"end != "+(o-1):"end != 0",i=n?"end + 1":"end - 1"):(s=n?`end + pow2 < ${o}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${qe(r)} coords = getOutputCoords();\n        int end = ${_a(r,"coords")};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${s}) {\n          int idx = ${i};\n          ${_a(r,"coords")} = idx;\n          val += getX(${Sa(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function Sa(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function _a(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const La={kernelName:r.Be,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s,exclusive:i,reverse:c}=a,u=o.shape.length,l=Object(r.Dd)([s],u);let d=o;null!=l&&(d=Mn({inputs:{x:o},backend:n,attrs:{perm:l}}));const p=Object(r.Ed)(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);const h=o.shape[p];let f=pn({inputs:{x:d},backend:n});for(let e=0;e<=Math.ceil(Math.log2(h))-1;e++){const t=new Aa(d.shape,!1,c),r=t.getCustomSetupFunc(e),a=f;f=n.runWebGLProgram(t,[f],f.dtype,r),n.disposeIntermediateTensorInfo(a)}if(i){const e=new Aa(d.shape,i,c),t=f;f=n.runWebGLProgram(e,[f],f.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=Mn({inputs:{x:f},backend:n,attrs:{perm:Object(r.Ce)(l)}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),e}return f}};const Da={kernelName:r.Xc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:s,binaryOutput:i}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(o.dataId),r=Ct(e,t,o.dtype,o.shape,s);return n.makeTensorInfo([s],o.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(o),r=$t(e,t,s,i);return n.makeTensorInfo(r.shape,o.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class Pa{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Ba={kernelName:r.De,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{blockSize:s,dataFormat:i}=a;Object(r.F)(s>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`));const c=o.shape[0],u="NHWC"===i?o.shape[1]:o.shape[2],l="NHWC"===i?o.shape[2]:o.shape[3],d="NHWC"===i?o.shape[3]:o.shape[1],p=u*s,h=l*s,f=d/(s*s),x=new Pa("NHWC"===i?[c,p,h,f]:[c,f,p,h],s,i);return n.runWebGLProgram(x,[o],o.dtype)}};class ja{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.inHeight,s=e.inWidth,i=e.padInfo.top,c=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,x=e.outChannels/e.inChannels;let g="",m="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,m="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${l});\n      const ivec2 pads = ivec2(${i}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${x};\n        int q = d2 - d1 * ${x};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${o}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${s}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${m}\n        setOutput(result);\n      }\n    `}}class Wa{constructor(e,t=!1,n=null,a=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const s=e.inHeight,i=e.inWidth,c=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,d=e.strideWidth,p=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,x=e.filterWidth,g=x;let m="int xR; int xC; int xCOffset;";for(let e=0;e<f;e++)for(let t=0;t<x;t++)m+=`\n          vec4 xTexelR${e}C${2*t} = vec4(0.);\n          vec4 wR${e}C${t} = vec4(0.);\n          vec4 xR${e}C${t} = vec4(0.);`;for(let e=0;e<f;e++)for(let t=0;t<g;t++){const n=2*t;if(m+=`\n          xR = xRCorner + ${e*p};\n          xC = xCCorner + ${n*h};\n        `,1===d){if(n<x&&(m+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${i}) {\n                    xTexelR${e}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${i}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${i}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${e}C${n} = vec4(previous.zw, xTexelR${e}C${n}.xy);\n                } else {\n                  xR${e}C${n} = vec4(0, 0, xTexelR${e}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${s} && xC >= 0 && xC < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xR${e}C${n} = xTexelR${e}C${n};\n              `,n+1<x)){const t=u%2==0?Object(r.Ud)(h):h;h%2==0&&u%2==1||h%2!=0&&u%2!=1?(m+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${i}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,h>1&&(m+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${s} &&\n                      xCOffset >= 0 && xCOffset < ${i}) {\n                      xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${e}C${n} = vec4(0.);\n                    }\n                  `),m+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.xy);\n                `):m+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${i}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${e}C${n+1} = xTexelR${e}C${n+2};\n                `}}else n<x&&(m+=`\n              if(xR >= 0 && xR < ${s}) {\n            `,u%2==1?(m+=`\n                xCOffset = xC + 1 - ${d};\n                if(xCOffset >= 0 && xCOffset < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${i}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n              `,n+1<x&&(m+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${d};\n                  if(xCOffset >= 0 && xCOffset < ${i}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${e}C${n+1} = vec4(xTexelR${e}C${n+2}.xy, final.xy);\n                `)):(m+=`\n                if(xC >= 0 && xC < ${i}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${d};\n                if(xCOffset >= 0 && xCOffset < ${i}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.xy, xTexelR${e}C${n+2}.xy);\n              `,n+1<x&&(m+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n                `)),m+="}");n<x&&(m+=`\n            vec4 wTexelR${e}C${n} = getW(${e}, ${n}, d1, q);\n            wR${e}C${n} = vec4(wTexelR${e}C${n}.xz, wTexelR${e}C${n}.xz);\n          `,n+1<x&&(m+=`\n              vec4 wTexelR${e}C${n+1} = getW(${e}, ${n+1}, d1, q);\n              wR${e}C${n+1} =\n                vec4(wTexelR${e}C${n+1}.xz, wTexelR${e}C${n+1}.xz);`))}for(let e=0;e<f;e++)for(let t=0;t<x;t++)m+=`dotProd += xR${e}C${t} * wR${e}C${t};`;let b="",C="";n&&(b=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,C="result = activation(result);");const $=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${l}, ${d});\n      const ivec2 pads = ivec2(${c}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${m}\n\n        vec4 result = dotProd;\n        ${$}\n        ${C}\n        setOutput(result);\n      }\n    `}}const Va={kernelName:r.Ee,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,filter:s}=t,{strides:i,pad:c,dilations:u,dimRoundingMode:l}=a;let d=u;null==d&&(d=[1,1]),Object(r.F)(Object(r.Sc)(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));const p=Object(r.mc)(o.shape,s.shape,i,d,c,l,!0);let h;return h=Object(r.Bf)().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new Wa(p):new ja(p),n.runWebGLProgram(h,[o,s],"float32")}};class Ma{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${o} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ua{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ga={kernelName:r.Fe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,dy:s}=t,{strides:i,dilations:c,pad:u,dimRoundingMode:l,filterShape:d}=a,p=Object(r.mc)(o.shape,d,i,c,u,l,!0),h=new Ma(p);return n.runWebGLProgram(h,[o,s],"float32")}};const za={kernelName:r.Ge,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,filter:s}=t,{strides:i,dilations:c,pad:u,dimRoundingMode:l,inputShape:d}=a,p=Object(r.mc)(d,s.shape,i,c,u,l,!0),h=new Ua(p);return n.runWebGLProgram(h,[o,s],"float32")}};class Xa{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Ha={kernelName:r.He,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,o=[...a.shape,...a.shape],s=Object(r.Ec)(a.shape),i=An({inputs:{x:a},backend:n,attrs:{shape:[s]}}),c=new Xa(s),u=n.runWebGLProgram(c,[i],i.dtype),l=An({inputs:{x:u},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}};class Ka{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:c,dilationWidth:u}=e,{top:l,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${l}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${s}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const Ya={kernelName:r.Ie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,filter:s}=t,{strides:i,pad:c,dilations:u}=a,l=Object(r.Je)(o.shape,s.shape,i,c,"NHWC",u);let d;const p=new Ka(l);d=n.runWebGLProgram(p,[o,s],"float32");const h=An({inputs:{x:d},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(d),h}},qa=In({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Qa={kernelName:r.Ke,backendName:"webgl",kernelFunc:qa},Za={kernelName:r.Le,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:o}=t,s=Object(r.Bf)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dn("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,o.shape):new ln("return (b >= 1.0) ? a : a * (b + 1.0);",a.shape,o.shape);return n.runWebGLProgram(s,[a,o],a.dtype)}},Ja=Rn({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),eo={kernelName:r.Me,backendName:"webgl",kernelFunc:Ja},to=In({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${a.a};\n  float a1 = ${a.m};\n  float a2 = ${a.o};\n  float a3 = ${a.p};\n  float a4 = ${a.q};\n  float a5 = ${a.r};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),no={kernelName:r.Ne,backendName:"webgl",kernelFunc:to},ro="return exp(x);",ao=In({opSnippet:ro,packedOpSnippet:ro,cpuKernelImpl:Rt}),oo={kernelName:r.Oe,backendName:"webgl",kernelFunc:ao};function so(e){const{inputs:t,attrs:n,backend:a}=e,{dim:o}=n,{input:s}=t,i=s.shape.length,c=s.shape.slice();let u=o;return o<0&&(Object(r.F)(-(i+1)<=o,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),u=i+o+1),c.splice(u,0,1),An({inputs:{x:s},backend:a,attrs:{shape:c}})}const io={kernelName:r.Pe,backendName:"webgl",kernelFunc:so},co="return exp(x) - 1.0;",uo=In({opSnippet:co,packedOpSnippet:co,cpuKernelImpl:Ot}),lo={kernelName:r.Qe,backendName:"webgl",kernelFunc:uo};class po{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);s="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${s}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function ho(e,t,n){const a=n.texData.get(e.dataId),o=Object(r.Ec)(e.shape),s=e.shape[e.shape.length-1],i=An({inputs:{x:e},backend:n,attrs:{shape:[o/s,s]}}),c=i.shape,u=new po("real",c,t),l=new po("imag",c,t),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:c},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:c}],p=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(l,d,"float32"),f=fn({inputs:{real:p,imag:h},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h);const x=An({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(f),x}const fo={kernelName:r.Re,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ho(r,!1,n)}};class xo{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function go(e){const{backend:t,attrs:n}=e,{shape:a,value:o}=n;let{dtype:s}=n;if(s=s||Object(r.Se)(o),"string"===s){const e=Object(r.ee)(s,Object(r.Ec)(a));return e.fill(o),t.makeTensorInfo(a,s,e)}{const e=new xo(a,o),n=e.getCustomSetupFunc(o);return t.runWebGLProgram(e,[],s,n)}}const mo={kernelName:r.Zc,backendName:"webgl",kernelFunc:go};class bo{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Co={kernelName:r.Bc,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,a=new bo(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},$o="return floor(x);",vo=In({opSnippet:$o,packedOpSnippet:$o,cpuKernelImpl:wt}),Io={kernelName:r.Te,backendName:"webgl",kernelFunc:vo},Ro=Rn({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Oo={kernelName:r.Ue,backendName:"webgl",kernelFunc:Ro};class wo{constructor(e){this.variableNames=["A"];const t=se(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class ko{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=se(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const yo={kernelName:r.Pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:o}=t;const{numChannels:s}=a,i="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,c="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,l="undefined"!=typeof ImageBitmap&&o instanceof ImageBitmap,[d,p]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],h=[p,d],f=[p,d,s];(c||i||l)&&(null==Eo&&(Eo=document.createElement("canvas").getContext("2d")),Eo.canvas.width=d,Eo.canvas.height=p,Eo.drawImage(o,0,0,d,p),o=Eo.canvas);const x=n.makeTensorInfo(h,"int32");n.texData.get(x.dataId).usage=u.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(x.dataId),o);const g=Object(r.Bf)().getBool("WEBGL_PACK")?new ko(f):new wo(f),m=n.runWebGLProgram(g,[x],"int32");return n.disposeData(x.dataId),m}};let Eo;const No={kernelName:r.qc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,filter:s,bias:i,preluActivationWeights:c}=t,{strides:u,pad:l,dataFormat:d,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:x}=a,g=Object(r.tf)(d),m=Object(r.mc)(o.shape,s.shape,u,p,l,h,!1,g);let b;const C=[];if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(Object(r.Bf)().getBool("WEBGL_CONV_IM2COL")&&1===o.shape[0])b=xa({x:o,filter:s,convInfo:m,backend:n,bias:i,activation:f,preluActivationWeights:c,leakyreluAlpha:x});else{const e=null!=i,t=null!=c,a="leakyrelu"===f,u=f?On(f,!1):null,l=new da(m,e,u,t,a),d=[o,s];if(i&&d.push(i),c&&d.push(c),a){const e=n.makeTensorInfo([],"float32",Object(r.fe)(x,"float32"));d.push(e),C.push(e)}b=n.runWebGLProgram(l,d,"float32")}else b=fa({x:o,filter:s,convInfo:m,backend:n,bias:i,activation:f,preluActivationWeights:c,leakyreluAlpha:x});const $=An({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return C.push(b),C.forEach((e=>n.disposeIntermediateTensorInfo(e))),$}};const To={kernelName:r.wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,filter:s,bias:i,preluActivationWeights:c}=t,{strides:u,pad:l,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a,x=[];let g=d;null==g&&(g=[1,1]),Object(r.F)(Object(r.Sc)(u,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`));const m=Object(r.mc)(o.shape,s.shape,u,g,l,p,!0),b=Object(r.Bf)().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,C=h?On(h,b):null,$=[o,s],v=null!=i,I=null!=c,R="leakyrelu"===h;if(v&&$.push(i),I&&$.push(c),R){const e=n.makeTensorInfo([],"float32",Object(r.fe)(f,"float32"));$.push(e),x.push(e)}let O;O=b?new Wa(m,v,C,I,R):new ja(m,v,C,I,R);const w=n.runWebGLProgram(O,$,"float32");return x.forEach((e=>n.disposeIntermediateTensorInfo(e))),w}};class Fo{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=qe(t.length),a=qe(n.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${o};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const Ao={kernelName:r.jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:o,indices:s}=t,i=s.shape,c=i[i.length-1],[u,l,d,p]=Object(a.s)(o,s),h=An({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),f=An({inputs:{x:o},backend:n,attrs:{shape:[Object(r.Ec)(o.shape)/d,d]}}),x=new Fo(c,p,[l,d]),g=n.runWebGLProgram(x,[f,h],f.dtype),m=An({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};class So{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=qe(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}const _o={kernelName:r.Ve,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:s,indices:i}=t,{axis:c,batchDims:u}=o,l=Object(r.ke)(c,s.shape)[0],d=Object(a.t)(s,i,l,u),p=Object(r.Ec)(i.shape),h=[],f=An({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),x=An({inputs:{x:i},backend:n,attrs:{shape:[d.batchSize,p/d.batchSize]}});h.push(f),h.push(x);const g=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const e=n.bufferSync(x),t=n.bufferSync(f),r=kt(t,e,g);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(d.outputShape,r.dtype,r.values)}const m=new So(f.shape,g),b=n.runWebGLProgram(m,[f,x],f.dtype);h.push(b);const C=An({inputs:{x:b},backend:n,attrs:{shape:d.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}},Lo=Rn({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:yt,dtype:"bool"}),Do={kernelName:r.We,backendName:"webgl",kernelFunc:Lo},Po=Rn({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),Bo={kernelName:r.Xe,backendName:"webgl",kernelFunc:Po};const jo={kernelName:r.Ye,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ho(r,!0,n)}},Wo=In({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Vo={kernelName:r.Ze,backendName:"webgl",kernelFunc:Wo},Mo=In({opSnippet:"return float(isinf(x));",dtype:"bool"}),Uo={kernelName:r.af,backendName:"webgl",kernelFunc:Mo},Go=In({opSnippet:"return float(isnan(x));",dtype:"bool"}),zo={kernelName:r.bf,backendName:"webgl",kernelFunc:Go},Xo=Rn({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Et,dtype:"bool"}),Ho={kernelName:r.qe,backendName:"webgl",kernelFunc:Xo},Ko=Rn({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),Yo={kernelName:r.Df,backendName:"webgl",kernelFunc:Ko};const qo={kernelName:r.ad,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:o}=n,s=Nt(r,a,o);return t.makeTensorInfo([s.length],"float32",s)}},Qo=In({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Tt}),Zo={kernelName:r.Ef,backendName:"webgl",kernelFunc:Qo},Jo=In({opSnippet:"return log(1.0 + x);"}),es={kernelName:r.Ff,backendName:"webgl",kernelFunc:Jo},ts=Rn({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),ns={kernelName:r.Gf,backendName:"webgl",kernelFunc:ts},rs=In({opSnippet:"return float(!(x >= 1.0));"}),as={kernelName:r.Hf,backendName:"webgl",kernelFunc:rs},os=Rn({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),ss={kernelName:r.If,backendName:"webgl",kernelFunc:os};class is{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const o=t,s=e[3]-1;let i;this.outputShape=e;const c=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${c})`:1===a?`1.0/(${c})`:`exp(log(${c}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class cs{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,s=e[3]-1;let i;this.outputShape=e;const c=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${c})`:1===a?`1.0/(${c})`:`exp(log(${c}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}const us={kernelName:r.Jf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{depthRadius:s,bias:i,alpha:c,beta:u}=a,l=Object(r.Bf)().getBool("WEBGL_PACK_NORMALIZATION")?new cs(o.shape,s,i,c,u):new is(o.shape,s,i,c,u);return n.runWebGLProgram(l,[o],o.dtype)}};class ls{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const ds={kernelName:r.Kf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:o,dy:s}=t,{depthRadius:i,bias:c,alpha:u,beta:l}=r,d=new ls(a.shape,i,c,u,l);return n.runWebGLProgram(d,[a,o,s],a.dtype)}};function ps(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{reductionIndices:s,keepDims:i}=a,c=o.shape.length,u=Object(r.ke)(s,o.shape);let l=u;const d=Object(r.Dd)(l,c),p=null!=d,h=n.shouldExecuteOnCPU([o]);let f=o;if(p){if(h){const e=n.texData.get(f.dataId).values,t=new Array(c);for(let e=0;e<t.length;e++)t[e]=o.shape[d[e]];const r=zt(e,o.shape,o.dtype,d,t);f=n.makeTensorInfo(t,o.dtype);n.texData.get(f.dataId).values=r}else f=jn(o,d,n);l=Object(r.Ed)(l.length,c)}Object(r.Fd)("max",l,c);const[x,g]=Object(r.ge)(f.shape,l);let m,b=x;if(i&&(b=Object(r.Pd)(x,u)),h){const e=n.texData.get(f.dataId).values,t=Ft(e,Object(r.Ec)(g),b,o.dtype);m=n.makeTensorInfo(b,o.dtype);n.texData.get(m.dataId).values=t}else m=function(e,t,n,a){const o=Object(r.Ec)(t),s=An({inputs:{x:e},attrs:{shape:[Object(r.Ec)(e.shape)/o,o]},backend:a}),i=Dn(s,e.dtype,"max",a),c=An({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),c}(f,g,b,n);return p&&n.disposeIntermediateTensorInfo(f),m}const hs={kernelName:r.Lf,backendName:"webgl",kernelFunc:ps},fs=Rn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:At}),xs={kernelName:r.Mf,backendName:"webgl",kernelFunc:fs};const gs={kernelName:r.og,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t;ae(o,"maxPool");const{filterSize:s,strides:i,pad:c,dimRoundingMode:u}=a;Object(r.F)(Object(r.Sc)(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const l=Object(r.ye)(o.shape,s,i,1,c,u);if(1===l.filterWidth&&1===l.filterHeight&&Object(r.gb)(l.inShape,l.outShape))return pn({inputs:{x:o},backend:n});const d=new Rr(l,"max",!1);return n.runWebGLProgram(d,[o],o.dtype)}};const ms={kernelName:r.bd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{filterSize:s,strides:i,pad:c,dataFormat:u,dimRoundingMode:l}=a,d=Object(r.ze)(o.shape,s,i,[1,1,1],c,l,u),p=new Or(d,"max",!1);return n.runWebGLProgram(p,[o],o.dtype)}};class bs{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=a-1-e.padInfo.top,i=o-1-e.padInfo.left,c=a*o-1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Cs{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.front,d=c-1-e.padInfo.top,p=u-1-e.padInfo.left,h=i*c*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${l}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${o}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${s}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const $s={kernelName:r.pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,input:s}=t,i=s,{filterSize:c,strides:u,pad:l,dimRoundingMode:d}=a,p=Object(r.ze)(i.shape,c,u,[1,1,1],l,d),h=new Or(p,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),x=new Cs(p),g=n.runWebGLProgram(x,[o,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const vs={kernelName:r.qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:o,input:s,output:i}=t,c=s;ae([s,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:d,dimRoundingMode:p}=a,h=Object(r.ye)(c.shape,u,l,1,d,p),f=new Rr(h,"max",!0),x=n.runWebGLProgram(f,[c],c.dtype),g=new bs(h),m=n.runWebGLProgram(g,[o,x],c.dtype);return n.disposeIntermediateTensorInfo(x),m}};const Is={kernelName:r.bc,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:o,strides:s,pad:i,includeBatchInIndex:c}=t,u=n;Object(r.F)(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const l=[1,1];Object(r.F)(Object(r.Sc)(s,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`));const d=Object(r.ye)(a.shape,o,s,l,i),[p,h]=function(e,t,n,r){let a=new Rr(n,"max",!1);const o=r.runWebGLProgram(a,[e],"float32");return a=new Rr(n,"max",!0,!0,t),[o,r.runWebGLProgram(a,[e],"float32")]}(a,c,d,u);return[p,h]}};const Rs={kernelName:r.rg,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{keepDims:o,axis:s}=t,i=n,c=a.shape.length,u=Object(r.ke)(s,a.shape);let l=u;const d=Object(r.Dd)(l,c),p=null!=d,h=i.shouldExecuteOnCPU([a]),f=[];let x=a;if(p){if(h){const e=i.texData.get(x.dataId).values,t=new Array(c);for(let e=0;e<t.length;e++)t[e]=a.shape[d[e]];const n=zt(e,a.shape,a.dtype,d,t);x=i.makeTensorInfo(t,a.dtype);i.texData.get(x.dataId).values=n}else x=jn(a,d,i);f.push(x),l=Object(r.Ed)(l.length,c)}Object(r.Fd)("sum",l,c);const[g,m]=Object(r.ge)(x.shape,l);let b=g;o&&(b=Object(r.Pd)(g,u));const C=function(e,t,n,a){const o=Object(r.Ec)(t),s=An({inputs:{x:e},attrs:{shape:[Object(r.Ec)(e.shape)/o,o]},backend:a}),i=Dn(s,"float32","mean",a),c=An({inputs:{x:i},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),c}(x,m,b,i);for(const e of f)i.disposeIntermediateTensorInfo(e);return C}};const Os={kernelName:r.sg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s,keepDims:i}=a,c=o.shape.length,u=Object(r.ke)(s,o.shape);let l=u;const d=Object(r.Dd)(l,c);let p=o;null!=d&&(p=Mn({inputs:{x:o},backend:n,attrs:{perm:d}}),l=Object(r.Ed)(l.length,o.shape.length)),Object(r.Fd)("min",l,c);const[h,f]=Object(r.ge)(p.shape,l),x=An({inputs:{x:p},backend:n,attrs:{shape:[-1,Object(r.Ec)(f)]}}),g=Dn(x,x.dtype,"min",n);let m;if(i){m=An({inputs:{x:g},backend:n,attrs:{shape:Object(r.Pd)(h,u)}})}else m=An({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(p),m}},ws=Rn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:St}),ks={kernelName:r.tg,backendName:"webgl",kernelFunc:ws};class ys{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=qe(r),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${o});\n      ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Es{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=qe(r),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=Kt("rc",r),c=Kt("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,l=1===r?"source":`vec2(${c.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${c.join()}), ${l});\n        ${i[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${c.join()}), ${l});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${c.join()}), ${l});\n        ${i[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${c.join()}), ${l});\n        }\n        rc = outputLoc;\n        ${i[r-2]} += 1;\n        if(${i[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${c.join()}), ${l});\n          ${i[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${c.join()}), ${l});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${o});\n      const ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const Ns={kernelName:r.ug,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{paddings:o,mode:s}=n,i=Object(r.Bf)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Es(a.shape,o,s):new ys(a.shape,o,s);return t.runWebGLProgram(i,[a],a.dtype)}},Ts=Rn({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Fs={kernelName:r.vg,backendName:"webgl",kernelFunc:Ts};class As{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const Ss=Rn({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),_s={kernelName:r.wg,backendName:"webgl",kernelFunc:Ss},Ls="return a - b;",Ds=Rn({opSnippet:Ls,packedOpSnippet:Ls,supportsComplex:!0,cpuKernelImpl:Mt}),Ps={kernelName:r.xg,backendName:"webgl",kernelFunc:Ds};function Bs(e){const{inputs:t,backend:n,attrs:a}=e,{logits:o}=t,{dim:s}=a,i=Object(r.ke)([s],o.shape),c=ps({inputs:{x:o},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=Object(r.Pd)(c.shape,i),l=An({inputs:{x:c},backend:n,attrs:{shape:u}}),d=Ds({inputs:{a:o,b:l},backend:n}),p=ao({inputs:{x:d},backend:n}),h=Wn({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:!1}}),f=An({inputs:{x:h},backend:n,attrs:{shape:u}}),x=Ss({inputs:{a:p,b:f},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),x}const js={kernelName:r.yg,backendName:"webgl",kernelFunc:Bs};const Ws={kernelName:r.cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:o,seed:s,normalized:i}=r,c=i?a:Bs({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=c.shape[0],l=c.shape[1],d=new As(u,l,o),p=d.getCustomSetupFunc(s),h=n.runWebGLProgram(d,[c],"int32",p);return i||n.disposeIntermediateTensorInfo(c),h}},Vs="return -x;";const Ms={kernelName:r.zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=Lt(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let o;return o=Object(r.Bf)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new an(a.shape,Vs):new tn(a.shape,Vs),n.runWebGLProgram(o,[a],a.dtype)}},Us=r.fd;const Gs={kernelName:r.ed,backendName:"webgl",kernelFunc:function(e){Object(a.x)("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:c,scoreThreshold:u}=r,l=n.readSync(o.dataId),d=n.readSync(s.dataId),{selectedIndices:p}=Us(l,d,i,c,u);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}},zs=r.jd;const Xs={kernelName:r.id,backendName:"webgl",kernelFunc:function(e){Object(a.x)("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:c,scoreThreshold:u,padToMaxOutputSize:l}=r,d=n.readSync(o.dataId),p=n.readSync(s.dataId),{selectedIndices:h,validOutputs:f}=zs(d,p,i,c,u,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},Hs=r.hd;const Ks={kernelName:r.gd,backendName:"webgl",kernelFunc:function(e){Object(a.x)("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:c,scoreThreshold:u,softNmsSigma:l}=r,d=n.readSync(o.dataId),p=n.readSync(s.dataId),h=i,f=c,x=u,g=l,{selectedIndices:m,selectedScores:b}=Hs(d,p,h,f,x,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class Ys{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const qs={kernelName:r.Ag,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:o}=t,{depth:s,onValue:i,offValue:c}=a,u=Object(r.Ec)(o.shape),l=new Ys(u,s,i,c),d=An({inputs:{x:o},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(l,[d],o.dtype);n.disposeIntermediateTensorInfo(d);const h=An({inputs:{x:p},backend:n,attrs:{shape:[...o.shape,s]}});return n.disposeIntermediateTensorInfo(p),h}};function Qs(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Gr({inputs:{input:r},backend:n}),t=Qs({inputs:{x:e},backend:n}),a=oa({inputs:{input:r},backend:n}),o=Qs({inputs:{x:a},backend:n}),s=fn({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),s}return go({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Zs={kernelName:r.Bg,backendName:"webgl",kernelFunc:Qs};const Js={kernelName:r.Cg,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=Gr({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),o=oa({inputs:{input:a},backend:r}),s=Qs({inputs:{x:o},backend:r}),i=fn({inputs:{real:n,imag:s},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),i}return go({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const ei={kernelName:r.Dg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:o}=a;if(1===t.length)return so({inputs:{input:t[0]},backend:n,attrs:{dim:o}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Object(r.md)(s,e.shape,"All tensors passed to stack must have matching shapes"),Object(r.F)(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const c=[],u=ua({inputs:t.map((e=>{const t=so({inputs:{input:e},backend:n,attrs:{dim:o}});return c.push(t),t})),backend:n,attrs:{axis:o}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class ti{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=qe(r),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${o});\n      ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class ni{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=qe(r),o=t.map((e=>e[0])).join(","),s=t.map(((t,n)=>t[0]+e[n])).join(","),i=Kt("rc",r),c=Kt("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,l=1===r?"source":`vec2(${c.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${i[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${u}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=1===r?2:4;e<t;e++)h+=`\n        ${d[e]}\n        if (${p}) {\n          result[${e}] = float(${n});\n        } else {\n          ${a} source = rc - start;\n          result[${e}] = getChannel(getX(${c.join()}), ${l});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${o});\n      const ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const ri=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{paddings:s,constantValue:i}=a,c=Object(r.Bf)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ni(o.shape,s,i):new ti(o.shape,s,i);return n.runWebGLProgram(c,[o],o.dtype)},ai={kernelName:r.Eg,backendName:"webgl",kernelFunc:ri},oi=Rn({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),si={kernelName:r.Fg,backendName:"webgl",kernelFunc:oi};const ii={kernelName:r.Gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{axis:s,keepDims:i}=a,c=o.shape.length,u=[],l=Object(r.ke)(s,o.shape);let d=l;const p=Object(r.Dd)(d,c);let h,f=o;if(null!=p&&(f=Mn({inputs:{x:o},backend:n,attrs:{perm:p}}),d=Object(r.Ed)(d.length,c),u.push(f)),Object(r.Fd)("prod",d,c),n.shouldExecuteOnCPU([f])){const e=n.texData.get(f.dataId).values,{outVals:t,outShape:r,outDtype:a}=Dt(f.shape,f.dtype,e,d);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=Object(r.ge)(f.shape,d),a=Object(r.Ec)(t),s=An({inputs:{x:f},backend:n,attrs:{shape:[-1,a]}}),i=Dn(s,Object(r.Gd)(o.dtype),"prod",n);h=An({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(s),u.push(i)}if(i){u.push(h);const e=Object(r.Pd)(h.shape,l);h=An({inputs:{x:h},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},ci=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:o,dtype:s}=n,i=Pt(r,a,o,s);return t.makeTensorInfo([i.length],s,i)},ui={kernelName:r.dc,backendName:"webgl",kernelFunc:ci},li=In({opSnippet:"return 1.0 / x;"}),di={kernelName:r.Hg,backendName:"webgl",kernelFunc:li},pi=In({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),hi={kernelName:r.Ig,backendName:"webgl",kernelFunc:pi},fi=In({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),xi={kernelName:r.Jg,backendName:"webgl",kernelFunc:fi};class gi{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const u=[r&&t>1?s-1:s,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class mi{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const u=[r&&t>1?s-1:s,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const bi={kernelName:r.Kg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:c}=a,[u,l]=c,d=Object(r.Bf)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mi(o.shape,u,l,s,i):new gi(o.shape,u,l,s,i);return n.runWebGLProgram(d,[o],"float32")}};class Ci{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,s]=e,i=[n&&o>1?r-1:r,n&&s>1?a-1:a],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],u=i[0]/c[0],l=i[1]/c[1],d=1/u,p=1/l,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const $i={kernelName:r.Lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:s}=r,i=new Ci(o.shape,a.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class vi{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,s,i,c]=e;this.outputShape=[o,t,n,c];const u=[r&&t>1?s-1:s,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;p=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const Ii={kernelName:r.Mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:s,size:i}=r,[c,u]=i,l=new vi(a.shape,c,u,o,s);return n.runWebGLProgram(l,[a],a.dtype)}};class Ri{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,s]=e,i=[n&&o>1?r-1:r,n&&s>1?a-1:a],c=[n&&o>1?o-1:o,n&&s>1?s-1:s],u=i[0]/c[0],l=i[1]/c[1],d=1/u,p=1/l,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Oi={kernelName:r.Ng,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:s}=r,i=new Ri(o.shape,a.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}};class wi{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=qe(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class ki{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Kt("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,s=qe(n);function i(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${s} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const yi={kernelName:r.Nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{dims:s}=a,i=o.shape.length,c=Object(r.ke)(s,o.shape);if(0===i)return pn({inputs:{x:o},backend:n});const u=Object(r.Bf)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ki(o.shape,c):new wi(o.shape,c);return n.runWebGLProgram(u,[o],o.dtype)}};class Ei{constructor(e,t,n,r){this.variableNames=["Image"],this.outputShape=[];const o=e[1],s=e[2],i=Math.sin(t).toFixed(3),c=Math.cos(t).toFixed(3);this.outputShape=e;const[u,l]=Object(a.u)(r,o,s),d=u.toFixed(3),p=l.toFixed(3);let h="";h="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${d}) * ${c} - (float(y) - ${p}) * ${i};\n          float coordYFloat = (float(x) - ${d}) * ${i} + (float(y) - ${p}) * ${c};\n          int coordX = int(round(coordXFloat + ${d}));\n          int coordY = int(round(coordYFloat + ${p}));\n          ${h}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${o}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Ni={kernelName:r.Qb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:o,center:s}=t,i=n,c=new Ei(r.shape,a,o,s);return i.runWebGLProgram(c,[r],r.dtype)}},Ti=In({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Fi={kernelName:r.Of,backendName:"webgl",kernelFunc:Ti},Ai=In({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Bt}),Si={kernelName:r.Pf,backendName:"webgl",kernelFunc:Ai};class _i{constructor(e,t,n,r,a,o,s=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=qe(a.length),c=qe(o.length);let u="";1===n?u="i":2===n&&(u="i, j");const l=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${a});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${l});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const Li={kernelName:r.hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:o,updates:s}=t,{shape:i}=a,{sliceRank:c,numUpdates:u,sliceSize:l,strides:d,outputSize:p}=Object(r.Qf)(s,o,i),h=[p/l,l];if(0===p)return n.makeTensorInfo(i,o.dtype);const f=An({inputs:{x:o},backend:n,attrs:{shape:[u,c]}}),x=An({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),m=new _i(u,c,f.shape.length,x.shape.length,d,h),b=n.runWebGLProgram(m,[x,f,g],x.dtype),C=An({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),C}};class Di{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let r=0;r<t.length;r++)s.push(`${n[r]}`),r<e&&o.push(`${n[r]}`);r=o.join(),a=s.join()}const o=qe(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const Pi={kernelName:r.Rf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:o,e:s}=t,i=new Di(a.shape.length,o.shape,o.shape.length);return n.runWebGLProgram(i,[a,o,s],Object(r.he)(o.dtype,s.dtype))}},Bi=In({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${r.Tf};\n  float scale = ${r.Uf};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),ji={kernelName:r.Sf,backendName:"webgl",kernelFunc:Bi},Wi=In({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),Vi={kernelName:r.Vf,backendName:"webgl",kernelFunc:Wi},Mi=In({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Ui={kernelName:r.Wf,backendName:"webgl",kernelFunc:Mi},Gi=In({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),zi={kernelName:r.Xf,backendName:"webgl",kernelFunc:Gi},Xi=In({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Hi={kernelName:r.Yf,backendName:"webgl",kernelFunc:Xi},Ki=In({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Yi={kernelName:r.Zf,backendName:"webgl",kernelFunc:Ki},qi={kernelName:r.ag,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:o}=e,{x:s}=t,{blockShape:i,paddings:c}=o;Object(r.F)(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const u=i.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...c);for(let e=1+i.length;e<s.shape.length;++e)l.push([0,0]);const d=[],p=ri({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=Object(a.h)(p.shape,i,u,!1),f=Object(a.e)(h.length,i.length,!1),x=Object(a.f)(p.shape,i,u,!1),g=An({inputs:{x:p},backend:n,attrs:{shape:h}}),m=Mn({inputs:{x:g},backend:n,attrs:{perm:f}}),b=An({inputs:{x:m},backend:n,attrs:{shape:x}});return d.push(p),d.push(g),d.push(m),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const Qi={kernelName:r.ic,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:c}=a,{sliceRank:u,numUpdates:l,strides:d,outputSize:p}=Object(r.Qf)(s,o,c),h=new _i(l,u,o.shape.length,s.shape.length,d,[p,1],!1),f=n.runWebGLProgram(h,[s,o,i],s.dtype),x=An({inputs:{x:f},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),x}};const Zi={kernelName:r.bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:s}=t,{numOrSizeSplits:i,axis:c}=o,u=Object(r.ke)(c,s.shape)[0],l=Object(a.v)(s,i,u),d=s.shape.length,p=new Array(d).fill(0),h=s.shape.slice();return l.map((e=>{const t=[...h];t[u]=e;const r=Br({inputs:{x:s},backend:n,attrs:{begin:p,size:t}});return p[u]+=e,r}))}},Ji=In({opSnippet:"return sqrt(x);"}),ec={kernelName:r.cg,backendName:"webgl",kernelFunc:Ji},tc=In({opSnippet:"return x * x;"}),nc={kernelName:r.dg,backendName:"webgl",kernelFunc:tc},rc="return (a - b) * (a - b);",ac=Rn({opSnippet:rc,packedOpSnippet:rc}),oc={kernelName:r.eg,backendName:"webgl",kernelFunc:ac};const sc={kernelName:r.fg,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,a=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,o=new tn(r.shape,a);return n.runWebGLProgram(o,[r],r.dtype)}};class ic{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=qe(n.length),o=qe(n.length);let s="";if(1===r)s="coords * strides + begin";else{let e=0;s=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}const cc={kernelName:r.gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{begin:s,end:i,strides:c,beginMask:u,endMask:l,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:h}=a,{nonStrided:f,$begin:x,$strides:g,size:m,newShape:b,outShape:C}=Object(r.hg)(o.shape,s,i,c,u,l,d,p,h),$=An({inputs:{x:o},backend:n,attrs:{shape:b}});let v;if(f){const e=Br({inputs:{x:$},backend:n,attrs:{begin:x,size:m}});v=An({inputs:{x:e},backend:n,attrs:{shape:C}}),n.disposeIntermediateTensorInfo(e)}else if(C.some((e=>0===e)))v=n.makeTensorInfo(C,o.dtype,[]);else{if(n.shouldExecuteOnCPU([$])){const e=n.texData.get($.dataId).values,t=Object(r.Yc)($.shape,$.dtype,e),a=Vt(C,t,g,x);v=n.makeTensorInfo(C,$.dtype,a.values)}else{const e=new ic(x,g,C);v=n.runWebGLProgram(e,[$],$.dtype)}}const I=An({inputs:{x:v},backend:n,attrs:{shape:C}});return n.disposeIntermediateTensorInfo($),n.disposeIntermediateTensorInfo(v),I}},uc=In({opSnippet:"return tan(x);"}),lc={kernelName:r.ig,backendName:"webgl",kernelFunc:uc},dc=In({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),pc={kernelName:r.jg,backendName:"webgl",kernelFunc:dc};class hc{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=qe(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function fc(e){const{inputs:t,backend:n,attrs:a}=e,{x:o}=t,{reps:s}=a;if("string"===o.dtype){const e=n.readSync(o.dataId).map((e=>Object(r.od)(e))),t=Object(r.Yc)(o.shape,o.dtype,e),a=Ut(t,s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const i=new hc(o.shape,s);return n.runWebGLProgram(i,[o],o.dtype)}const xc={kernelName:r.kg,backendName:"webgl",kernelFunc:fc};const gc={kernelName:r.lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:o,sorted:s}=r,i=n.readSync(a.dataId),[c,u]=Gt(i,a.shape,a.dtype,o,s);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const mc={kernelName:r.mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:o}=t;ae(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=r.readSync(o.dataId),{outputValues:i,outputShape:c,indices:u}=Xt(s,a,o.shape,o.dtype);return[r.makeTensorInfo(c,o.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}};const bc={kernelName:r.ng,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:o}=r;o<0&&(o+=a.shape.length);const s=a,i=s.shape.length,c=a.shape[o],u=new Array(i-1);let l=0;for(let e=0;e<i;e++)e!==o&&(u[l++]=s.shape[e]);const d=[],p=new Array(i).fill(0),h=s.shape.slice();h[o]=1;const f=new Array(c);for(let e=0;e<f.length;e++){p[o]=e;const t=Br({inputs:{x:s},backend:n,attrs:{begin:p,size:h}}),r=An({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class Cc{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,o=e.numSegments,s=o*Math.ceil(a/n);this.outputShape=[r,s];const i=4*Math.floor(n/4),c=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let l="";a%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const $c=[us,ds,zn,Hn,Yn,Qn,er,rr,ar,or,dr,pr,fr,gr,$r,br,Ir,kr,wr,Nr,Tr,Fr,_r,Wr,Vr,Xr,Yr,Zr,ta,xn,la,va,Ia,ga,Oa,wa,Ra,ya,Na,Fa,La,Da,Ba,Ga,za,Va,Ha,Ya,Qa,Za,eo,no,oo,io,lo,fo,mo,Co,Io,Oo,yo,No,To,Ao,_o,Do,Bo,hn,jo,sa,Vo,Uo,zo,bn,Ho,Yo,qo,es,Zo,ns,as,ss,hs,ms,gs,$s,vs,Is,xs,Rs,Os,ks,Ns,Fs,Ws,Fn,Ms,Gs,Xs,Ks,Ur,qs,Js,ei,ai,si,vn,ii,ui,zr,_s,di,xi,hi,Sn,bi,$i,Ii,Oi,yi,Ni,Fi,Si,Li,Pi,ji,Vi,Ui,zi,Hi,jr,js,Yi,qi,Qi,Zi,ec,nc,oc,sc,cc,Ps,Vn,lc,pc,xc,gc,Un,mc,bc,{kernelName:r.Cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:s,segmentIds:i}=t,{numSegments:c}=o,u=s.shape.length,l=[];let d=0;const p=Object(r.Dd)([d],u);let h=s;null!=p&&(h=Mn({inputs:{x:s},backend:n,attrs:{perm:p}}),l.push(h),d=Object(r.Ed)(1,u)[0]);const f=Object(a.w)(h.shape,d,c),x=Object(r.Ec)([h.shape[d]]),g=An({inputs:{x:h},backend:n,attrs:{shape:[-1,x]}});l.push(g);const m=Object(r.Gd)(s.dtype),b=(e,t,r,o,s)=>{const i=e.shape[0],c=e.shape[1],u=Object(a.y)(c,s),d=new Cc({windowSize:u,inSize:c,batchSize:i,numSegments:s},t),p=n.compileAndRun(d,[e,r],o);if(l.push(p),p.shape[1]===s)return p;const h=ci({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=fc({inputs:{x:h},backend:n,attrs:{reps:[c/u]}});l.push(h),l.push(f);return b(p,t,f,o,s)},C=An({inputs:{x:b(g,"unsortedSegmentSum",i,m,c)},backend:n,attrs:{shape:f}});let $=C;if(null!=p){l.push(C);const e=Object(r.Ce)(p);$=Mn({inputs:{x:$},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),$}},Zs];for(const e of $c)Object(r.Pg)(e)}}]);