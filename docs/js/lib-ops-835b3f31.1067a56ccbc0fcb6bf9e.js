/*! For license information please see lib-ops-835b3f31.1067a56ccbc0fcb6bf9e.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{2:function(t,e,n){"use strict";n.d(e,"a",(function(){return O})),n.d(e,"b",(function(){return h})),n.d(e,"c",(function(){return l})),n.d(e,"d",(function(){return a})),n.d(e,"e",(function(){return i})),n.d(e,"f",(function(){return D})),n.d(e,"g",(function(){return C})),n.d(e,"h",(function(){return f})),n.d(e,"i",(function(){return j})),n.d(e,"j",(function(){return N})),n.d(e,"k",(function(){return w})),n.d(e,"l",(function(){return Q})),n.d(e,"m",(function(){return X})),n.d(e,"n",(function(){return W})),n.d(e,"o",(function(){return k})),n.d(e,"p",(function(){return v})),n.d(e,"q",(function(){return ft})),n.d(e,"r",(function(){return V})),n.d(e,"s",(function(){return E})),n.d(e,"t",(function(){return M})),n.d(e,"u",(function(){return tt})),n.d(e,"v",(function(){return Y})),n.d(e,"w",(function(){return y})),n.d(e,"x",(function(){return m})),n.d(e,"y",(function(){return G})),n.d(e,"z",(function(){return B})),n.d(e,"A",(function(){return H})),n.d(e,"B",(function(){return Z})),n.d(e,"C",(function(){return K})),n.d(e,"D",(function(){return U})),n.d(e,"E",(function(){return d})),n.d(e,"F",(function(){return q})),n.d(e,"G",(function(){return g}));n(35),n(19),n(28),n(25),n(95),n(9);var r=n(5),s=n(0);function o(t,e,n,r){!function(t){Object(s.F)(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){Object(s.F)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),Object(s.F)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),Object(s.F)(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let o=0;return Promise.all(t.map((s=>(s.then((s=>{const c=n+ ++o/t.length*(r-n);return e(c),s})),s))))}async function c(t,e){null==e&&(e={});const n=null==e.fetchFunc?Object(s.Bf)().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),c=(null==e.onProgress?await Promise.all(r):await o(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(c):await o(c,e.onProgress,.5,1)}async function a(t,e="",n,r){return i((t=>c(t,{requestInit:r})))(t,e,n)}function i(t){return async(e,n="",r)=>{const o=e.map((()=>!1)),c={},a=null!=r?r.map((()=>!1)):[],i=[];if(e.forEach(((t,e)=>{let n=0;t.weights.forEach((t=>{const u="quantization"in t?t.quantization.dtype:t.dtype,l=s.Dc[u]*Object(s.Ec)(t.shape),b=()=>{o[e]=!0,null==c[e]&&(c[e]=[]),c[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=r?r.forEach(((e,n)=>{e===t.name&&(b(),a[n]=!0)})):b(),i.push(t.name),n+=l}))})),!a.every((t=>t))){const t=r.filter(((t,e)=>!a[e]));throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${i.join(", ")}.`)}const u=o.reduce(((t,e,n)=>(e&&t.push(n),t)),[]),l=[];u.forEach((t=>{e[t].paths.forEach((t=>{const e=n+(n.endsWith("/")?"":"/")+t;l.push(e)}))}));const b=await t(l),h={};let d=0;return u.forEach((t=>{const n=e[t].paths.length;let r=0;for(let t=0;t<n;t++)r+=b[d+t].byteLength;const o=new ArrayBuffer(r),a=new Uint8Array(o);let i=0;for(let t=0;t<n;t++){const e=new Uint8Array(b[d+t]);a.set(e,i),i+=e.byteLength}c[t].forEach((t=>{const e=o.slice(t.groupOffset,t.groupOffset+t.sizeBytes),n=Object(s.Yb)(e,[t.manifestEntry]);for(const t in n)h[t]=n[t]})),d+=n})),h}}class u{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Object(s.F)("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Object(s.Bf)().platform.fetch,Object(s.F)(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&Object(s.F)(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:Object(s.Gc)(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest,s=e.generatedBy,o=e.convertedBy,c=e.format,a=e.signature,i=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let u,l;if(null!=r){const t=await this.loadWeights(r);[u,l]=t}const b={modelTopology:n,weightSpecs:u,weightData:l,generatedBy:s,convertedBy:o,format:c};null!=a&&(b.signature=a),null!=i&&(b.userDefinedMetadata=i);const h=e.modelInitializer;return h&&(b.modelInitializer=h),b}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}(e),o=this.weightPathPrefix||n,a=[];for(const e of t)a.push(...e.weights);const i=[],u=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?u.push(this.weightUrlConverter(t)):i.push(o+t+r);this.weightUrlConverter&&i.push(...await Promise.all(u));const l=await c(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,Object(s.Hc)(l)]}}function l(t){return null!=t.match(u.URL_SCHEME_REGEX)}u.URL_SCHEME_REGEX=/^https?:\/\//;const b=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>l(t))):l(t),n)return h(t,e)}return null};function h(t,e){return new u(t,e)}function d(t,e){return h(t,e)}let p;s.Fc.registerSaveRouter(b),s.Fc.registerLoadRouter(b);const O=Object(s.Mc)({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,o=!1,c=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)c=!0;else if(null!=t.getContext)a=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);i=!0}if(o){const e=2;if(o&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Object(s.Nc)(s.Pc,s.Oc.backendName)){const n={pixels:t},r={numChannels:e};return s.Oc.runKernel(s.Pc,n,r)}const[u,l]=o?[t.videoWidth,t.videoHeight]:[t.width,t.height];let b,h;if(a?b=t.getContext("2d").getImageData(0,0,u,l).data:r||n?b=t.data:(c||o||i)&&(null==p&&(p=document.createElement("canvas").getContext("2d")),p.canvas.width=u,p.canvas.height=l,p.drawImage(t,0,0,u,l),b=p.getImageData(0,0,u,l).data),4===e)h=new Int32Array(b);else{const t=u*l;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=b[4*n+t]}return function(t,e,n){if(Object(s.Ic)(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Object(s.Jc)(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(s.Kc)(t,e,r,n)}(h,[l,u,e],"int32")}});const f=Object(s.Mc)({addN_:function(t){Object(s.F)(Array.isArray(t),(()=>"The argument passed to tf.addN() must be a list of tensors")),Object(s.F)(t.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`));const e=t.map(((t,e)=>Object(s.Lc)(t,`tensors${e}`,"addN"))),n=e[0];e.forEach((t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),e.forEach((t=>{if(!Object(s.gb)(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=e;return s.Oc.runKernel(s.Qc,r)}});const j=Object(s.Mc)({avgPool3d_:function(t,e,n,r,o,c="NDHWC",a){null==a?a=[1,1,1]:Object(s.Rc)("dilations is deprecated, this field will be gone in v3.0.0.");const i=Object(s.Lc)(t,"x","avgPool3d","float32");let u=i,l=!1;4===i.rank&&(l=!0,u=Object(s.N)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Object(s.F)(5===u.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`)),Object(s.F)("NDHWC"===c,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${c}`)),Object(s.F)(Object(s.Sc)(n,a),(()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),null!=o&&Object(s.F)(Object(s.Tc)(r),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const b={x:u},h={filterSize:e,strides:n,pad:r,dimRoundingMode:o,dataFormat:c,dilations:a};let d=s.Oc.runKernel(s.Uc,b,h);return d=Object(s.Cb)(d,u.dtype),l?Object(s.N)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const m=Object(s.Mc)({bincount_:function(t,e,n){const r=Object(s.Lc)(t,"x","bincount"),o=Object(s.Lc)(e,"weights","bincount");Object(s.F)("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Object(s.F)(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Object(s.F)(o.size===r.size||0===o.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`));const c={x:r,weights:o},a={size:n};return s.Oc.runKernel(s.Vc,c,a)}});const g=Object(s.Mc)({concat2d_:function(t,e){return Object(s.K)(t,e)}});const w=Object(s.Mc)({conv3d_:function(t,e,n,r,o="NDHWC",c=[1,1,1]){const a=Object(s.Lc)(t,"x","conv3d"),i=Object(s.Lc)(e,"filter","conv3d");let u=a,l=!1;4===a.rank&&(l=!0,u=Object(s.N)(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Object(s.F)(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),Object(s.F)(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),Object(s.F)(u.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),Object(s.F)(Object(s.Sc)(n,c),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${c}'`)),Object(s.F)("NDHWC"===o,(()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`));const b={x:u,filter:i},h={strides:n,pad:r,dataFormat:o,dilations:c},d=s.Oc.runKernel(s.Wc,b,h);return l?Object(s.N)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const y=Object(s.Mc)({denseBincount_:function(t,e,n,r=!1){const o=Object(s.Lc)(t,"x","denseBincount"),c=Object(s.Lc)(e,"weights","denseBincount");Object(s.F)("int32"===o.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`)),Object(s.F)(o.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`)),Object(s.F)(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Object(s.F)(c.size===o.size||0===c.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${c.shape}.`));const a={x:o,weights:c},i={size:n,binaryOutput:r};return s.Oc.runKernel(s.Xc,a,i)}});const x=Object(s.Mc)({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const o=Object(s.Yc)([t,e],r),c=t<=e?t:e;for(let t=0;t<c;++t)o.set(1,t,t);const a=Object(s.N)(o.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return Object(s.eb)(Object(s.Vb)(a,0),[n[0],1,1]);if(2===n.length)return Object(s.eb)(Object(s.Vb)(Object(s.Vb)(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return Object(s.eb)(Object(s.Vb)(Object(s.Vb)(Object(s.Vb)(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function v(t,e,n){const r={shape:t,value:e,dtype:n};return s.Oc.runKernel(s.Zc,{},r)}function E(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return s.Oc.runKernel(s.ad,{},r)}const M=Object(s.Mc)({maxPool3d_:function(t,e=[1,1,1],n,r,o,c="NDHWC",a){null==a?a=[1,1,1]:Object(s.Rc)("dilations is deprecated, this field will be gone in v3.0.0.");const i=Object(s.Lc)(t,"x","maxPool3d");let u=i,l=!1;4===i.rank&&(l=!0,u=Object(s.N)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Object(s.F)(5===u.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`)),Object(s.F)("NDHWC"===c,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${c}`)),Object(s.F)(Object(s.Sc)(n,a),(()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),null!=o&&Object(s.F)(Object(s.Tc)(r),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const b={x:u},h={filterSize:e,strides:n,pad:r,dimRoundingMode:o,dataFormat:c,dilations:a},d=s.Oc.runKernel(s.bd,b,h);return l?Object(s.N)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const N=Object(s.Mc)({maxPoolWithArgmax_:function(t,e,n,r,o=!1){const c={x:Object(s.Lc)(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:o},i=s.Oc.runKernel(s.bc,c,a);return{result:i[0],indexes:i[1]}}});const k=Object(s.Mc)({multinomial_:function(t,e,n,r=!1){const o=Object(s.Lc)(t,"logits","multinomial"),c=o.size,a=o.rank;if(c<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${c}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const i={logits:1===a?Object(s.N)(o,[1,-1]):o},u={numSamples:e,seed:n,normalized:r},l=s.Oc.runKernel(s.cc,i,u);return 1===a?Object(s.N)(l,[l.size]):l}});var L=Object(r.c)((function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function s(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function o(t,e){var n=new r(t),o=e&&e.state,c=n.next;return c.int32=function(){return 4294967296*n.next()|0},c.double=function(){return c()+11102230246251565e-32*(2097152*c()|0)},c.quick=c,o&&("object"==typeof o&&s(o,n),c.state=function(){return s(n,{})}),c}e&&e.exports?e.exports=o:n&&n.amd?n((function(){return o})):this.alea=o}(r.a,t,!1)})),F=Object(r.c)((function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function s(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function o(t,e){var n=new r(t),o=e&&e.state,c=function(){return(n.next()>>>0)/4294967296};return c.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},c.int32=n.next,c.quick=c,o&&("object"==typeof o&&s(o,n),c.state=function(){return s(n,{})}),c}e&&e.exports?e.exports=o:n&&n.amd?n((function(){return o})):this.xor128=o}(r.a,t,!1)})),S=Object(r.c)((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function s(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function o(t,e){var n=new r(t),o=e&&e.state,c=function(){return(n.next()>>>0)/4294967296};return c.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},c.int32=n.next,c.quick=c,o&&("object"==typeof o&&s(o,n),c.state=function(){return s(n,{})}),c}e&&e.exports?e.exports=o:n&&n.amd?n((function(){return o})):this.xorwow=o}(r.a,t,!1)})),$=Object(r.c)((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],n^=(t^=t<<13)^t<<9,r[s]=n,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function s(t,e){return e.x=t.x.slice(),e.i=t.i,e}function o(t,e){null==t&&(t=+new Date);var n=new r(t),o=e&&e.state,c=function(){return(n.next()>>>0)/4294967296};return c.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},c.int32=n.next,c.quick=c,o&&(o.x&&s(o,n),c.state=function(){return s(n,{})}),c}e&&e.exports?e.exports=o:n&&n.amd?n((function(){return o})):this.xorshift7=o}(r.a,t,!1)})),T=Object(r.c)((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,o=e.i;return e.w=r=r+1640531527|0,n=s[o+34&127],t=s[o=o+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=s[o]=n^t,e.i=o,n+(r^r>>>16)|0},function(t,e){var n,r,s,o,c,a=[],i=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,i=Math.max(i,e.length)),s=0,o=-32;o<i;++o)e&&(r^=e.charCodeAt((o+32)%e.length)),0===o&&(c=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(c=c+1640531527|0,s=0==(n=a[127&o]^=r+c)?s+1:0);for(s>=128&&(a[127&(e&&e.length||0)]=-1),s=127,o=512;o>0;--o)r=a[s+34&127],n=a[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,a[s]=r^n;t.w=c,t.X=a,t.i=s}(e,t)}function s(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function o(t,e){null==t&&(t=+new Date);var n=new r(t),o=e&&e.state,c=function(){return(n.next()>>>0)/4294967296};return c.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},c.int32=n.next,c.quick=c,o&&(o.X&&s(o,n),c.state=function(){return s(n,{})}),c}e&&e.exports?e.exports=o:n&&n.amd?n((function(){return o})):this.xor4096=o}(r.a,t,!1)})),P=Object(r.c)((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function s(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function o(t,e){var n=new r(t),o=e&&e.state,c=function(){return(n.next()>>>0)/4294967296};return c.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},c.int32=n.next,c.quick=c,o&&("object"==typeof o&&s(o,n),c.state=function(){return s(n,{})}),c}e&&e.exports?e.exports=o:n&&n.amd?n((function(){return o})):this.tychei=o}(r.a,t,!1)})),I=Object.freeze({__proto__:null,default:{}}),_=Object(r.b)(I),A=Object(r.c)((function(t){!function(e,n){var r,s=this,o=256,c=n.pow(o,6),a=n.pow(2,52),i=2*a,u=255;function l(t,u,l){var f=[],j=p(d((u=1==u?{entropy:!0}:u||{}).entropy?[t,O(e)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(o):(t=new Uint8Array(o),(s.crypto||s.msCrypto).getRandomValues(t)),O(t)}catch(t){var n=s.navigator,c=n&&n.plugins;return[+new Date,s,c,s.screen,O(e)]}}():t,3),f),m=new b(f),g=function(){for(var t=m.g(6),e=c,n=0;t<a;)t=(t+n)*o,e*=o,n=m.g(1);for(;t>=i;)t/=2,e/=2,n>>>=1;return(t+n)/e};return g.int32=function(){return 0|m.g(4)},g.quick=function(){return m.g(4)/4294967296},g.double=g,p(O(m.S),e),(u.pass||l||function(t,e,r,s){return s&&(s.S&&h(s,m),t.state=function(){return h(m,{})}),r?(n.random=t,e):t})(g,j,"global"in u?u.global:this==n,u.state)}function b(t){var e,n=t.length,r=this,s=0,c=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);s<o;)a[s]=s++;for(s=0;s<o;s++)a[s]=a[c=u&c+t[s%n]+(e=a[s])],a[c]=e;(r.g=function(t){for(var e,n=0,s=r.i,c=r.j,a=r.S;t--;)e=a[s=u&s+1],n=n*o+a[u&(a[s]=a[c=u&c+e])+(a[c]=e)];return r.i=s,r.j=c,n})(o)}function h(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function d(t,e){var n,r=[],s=typeof t;if(e&&"object"==s)for(n in t)try{r.push(d(t[n],e-1))}catch(t){}return r.length?r:"string"==s?t:t+"\0"}function p(t,e){for(var n,r=t+"",s=0;s<r.length;)e[u&s]=u&(n^=19*e[u&s])+r.charCodeAt(s++);return O(e)}function O(t){return String.fromCharCode.apply(0,t)}if(n.seedrandom=l,p(n.random(),e),t.exports){t.exports=l;try{r=_}catch(t){}}}([],Math)}));A.alea=L,A.xor128=F,A.xorwow=S,A.xorshift7=$,A.xor4096=T,A.tychei=P;var z=A;class D{constructor(t,e,n,r,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=s||Math.random();this.random=z.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,s,o;do{r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s}while(o>=1||0===o);const c=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*c,e=this.mean+this.stdDev*s*c,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class C{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;const s=r||Math.random();this.randu=z.alea(s.toString()),this.randn=new D(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,s,o;for(;;){do{r=this.randn.nextValue(),o=1+this.c*r}while(o<=0);if(o*=o*o,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-o+Math.log(o)),s=this.randu(),s<e||Math.log(s)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class R{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=z.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const W=Object(s.Mc)({randomUniform_:function(t,e=0,n=1,r="float32",o){const c=Object(s.Yc)(t,r),a=new R(e,n,null,o);for(let t=0;t<c.values.length;t++)c.values[t]=a.nextValue();return c.toTensor()}});function G(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const o={start:t,stop:e,step:n,dtype:r};return s.Oc.runKernel(s.dc,{},o)}const B=async function(t,e){const n=Object(s.Lc)(t,"x","setdiff1d"),r=Object(s.Lc)(e,"y","setdiff1d");Object(s.F)(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Object(s.F)(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Object(s.F)(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const o=await n.data(),c=await r.data(),a=new Set(c);let i=0;for(let t=0;t<o.length;t++)a.has(o[t])||i++;const u=new s.ec([i],n.dtype),l=new s.ec([i],"int32");for(let t=0,e=0;t<o.length;t++)a.has(o[t])||(u.values[e]=o[t],l.values[e]=t,e++);return[u.toTensor(),l.toTensor()]};function V(t,e){Object(s.Ic)(t);const n=Object(s.Jc)(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(s.Kc)(t,null,n,e)}function q(t,e,n){if(Object(s.Ic)(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Object(s.Jc)(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(s.Kc)(t,e,r,n)}const H=Object(s.Mc)({truncatedNormal_:function(t,e=0,n=1,r,o){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const c=new D(e,n,r,!0,o),a=Object(s.Yc)(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=c.nextValue();return a.toTensor()}});const U=async function(t){const e=Object(s.Lc)(t,"condition","whereAsync","bool"),n=await e.data(),r=Object(s.fc)(e.shape,n);return t!==e&&e.dispose(),r};const K=Object(s.Mc)({scatterND_:function(t,e,n){const r=Object(s.Lc)(t,"indices","scatterND","int32"),o=Object(s.Lc)(e,"updates","scatterND");Object(s.gc)(o,r,n);const c={indices:r,updates:o},a={shape:n};return s.Oc.runKernel(s.hc,c,a)}});const Y=Object(s.Mc)({sparseToDense_:function(t,e,n,r=0){const o=Object(s.Lc)(t,"sparseIndices","sparseToDense","int32"),c=Object(s.Lc)(e,"sparseValues","sparseToDense"),a=Object(s.Lc)(r,"defaultValue","sparseToDense",c.dtype);!function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const c=e.size;if(0!==e.rank&&(1!==e.rank||c!==s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,c,n,a);const i={sparseIndices:o,sparseValues:c,defaultValue:a},u={outputShape:n};return s.Oc.runKernel(s.ic,i,u)}});const Z=Object(s.Mc)({gatherND_:function(t,e){const n=Object(s.Lc)(e,"indices","gatherND","int32"),r={params:Object(s.Lc)(t,"x","gatherND"),indices:n};return s.Oc.runKernel(s.jc,r)}});function J(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const c=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(c)}return V(s,"float32")}const X=Object(s.Mc)({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:o="NHWC",dilations:c=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:b}){if(u=u||"linear",!1===Object(s.kc)(s.Oc.state.gradientDepth,u)){let h=Object(s.vb)(t,e,n,r,o,c,a);return null!=i&&(h=Object(s.oh)(h,i)),Object(s.lc)(h,u,l,b)}const h=Object(s.Lc)(t,"x","conv2d"),d=Object(s.Lc)(e,"filter","conv2d");let p=h,O=!1;3===h.rank&&(O=!0,p=Object(s.N)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Object(s.F)(4===p.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),Object(s.F)(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),null!=a&&Object(s.F)(Object(s.Tc)(r),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`)),Object(s.F)(p.shape[3]===d.shape[2],(()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`)),Object(s.F)(Object(s.Sc)(n,c),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${c}'`)),Object(s.F)("NHWC"===o,(()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`));const f=Object(s.mc)(p.shape,d.shape,n,c,r,a);let j,m;null!=i&&(j=Object(s.Lc)(i,"bias","fused conv2d"),[j]=Object(s.nc)(j,h),Object(s.oc)(f.outShape,j.shape)),null!=l&&(m=Object(s.Lc)(l,"prelu weights","fused conv2d"));const g=(t,e)=>{const[o,a,i,l]=e,b=Object(s.rc)(t,i,u);Object(s.F)(Object(s.sc)(c),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${c}'`));const h=[Object(s.tc)(a.shape,b,o,n,r),Object(s.uc)(a,b,o.shape,n,r)];if(null!=l){const t=Object(s.vc)(l,b);h.push(t)}return h},w={x:p,filter:d,bias:j,preluActivationWeights:m},y={strides:n,pad:r,dataFormat:o,dilations:c,dimRoundingMode:a,activation:u,leakyreluAlpha:b};if(null==i){return Object(s.pc)(((t,e,n)=>{let r=s.Oc.runKernel(s.qc,w,y);return n([e,t,r]),O&&(r=Object(s.N)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:g}}))(p,d)}return Object(s.pc)(((t,e,n,r)=>{let o=s.Oc.runKernel(s.qc,w,y);return r([e,t,o,n]),O&&(o=Object(s.N)(o,[o.shape[1],o.shape[2],o.shape[3]])),{value:o,gradFunc:g}}))(p,d,j)}});const Q=Object(s.Mc)({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:o="NHWC",dilations:c=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:b}){if(!1===Object(s.kc)(s.Oc.state.gradientDepth,u)){let h=Object(s.tb)(t,e,n,r,o,c,a);return null!=i&&(h=Object(s.oh)(h,i)),Object(s.lc)(h,u,l,b)}const h=Object(s.Lc)(t,"x","depthwiseConv2d"),d=Object(s.Lc)(e,"filter","depthwiseConv2d");let p=h,O=!1;3===h.rank&&(O=!0,p=Object(s.N)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Object(s.F)(4===p.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`)),Object(s.F)(4===d.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`)),Object(s.F)(p.shape[3]===d.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`)),null==c&&(c=[1,1]),Object(s.F)(Object(s.Sc)(n,c),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${c}'`)),null!=a&&Object(s.F)(Object(s.Tc)(r),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`));const f=Object(s.mc)(p.shape,d.shape,n,c,r,a,!0);let j,m;null!=i&&(j=Object(s.Lc)(i,"bias","fused conv2d"),[j]=Object(s.nc)(j,h),Object(s.oc)(f.outShape,j.shape)),null!=l&&(m=Object(s.Lc)(l,"prelu weights","fused depthwiseConv2d"));const g=(t,e)=>{Object(s.F)(Object(s.sc)(c),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${c}'`));const[o,i,l,b]=e,h=Object(s.rc)(t,l,u),d=Object(s.xc)(i.shape,h,o,n,r,c,a),p=Object(s.yc)(i,h,o.shape,n,r,c,a);if(null!=b){return[d,p,Object(s.vc)(j,h)]}return[d,p]},w={x:p,filter:d,bias:j,preluActivationWeights:m},y={strides:n,pad:r,dataFormat:o,dilations:c,dimRoundingMode:a,activation:u,leakyreluAlpha:b};if(null==i){return Object(s.pc)(((t,e,n)=>{let r=s.Oc.runKernel(s.wc,w,y);return n([e,t,r]),O&&(r=Object(s.N)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:g}}))(p,d)}return Object(s.pc)(((t,e,n,r)=>{let o=s.Oc.runKernel(s.wc,w,y);return r([e,t,o,n]),O&&(o=Object(s.N)(o,[o.shape[1],o.shape[2],o.shape[3]])),{value:o,gradFunc:g}}))(p,d,j)}});const tt=Object(s.Mc)({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:o,activation:c="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(!1===Object(s.kc)(s.Oc.state.gradientDepth,c)){let u=Object(s.P)(t,e,n,r);return null!=o&&(u=Object(s.oh)(u,o)),Object(s.lc)(u,c,a,i)}let u=Object(s.Lc)(t,"a","fused matMul"),l=Object(s.Lc)(e,"b","fused matMul");[u,l]=Object(s.nc)(u,l);const b=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?l.shape[l.rank-2]:l.shape[l.rank-1],O=u.shape.slice(0,-2),f=l.shape.slice(0,-2),j=Object(s.Ec)(O),m=Object(s.Ec)(f);Object(s.F)(u.rank>=2&&l.rank>=2&&u.rank===l.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`)),Object(s.F)(Object(s.gb)(O,f),(()=>`Error in fused matMul: outer dimensions (${O}) and (${f}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`)),Object(s.F)(b===h,(()=>`Error in fused matMul: inner shapes (${b}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`));const g=u.shape.slice(0,-2).concat([d,p]),w=n?Object(s.N)(u,[j,b,d]):Object(s.N)(u,[j,d,b]),y=r?Object(s.N)(l,[m,p,h]):Object(s.N)(l,[m,h,p]);let x,v;null!=o&&(x=Object(s.Lc)(o,"bias","fused matMul"),[x]=Object(s.nc)(x,u),Object(s.oc)(g,x.shape)),null!=a&&(v=Object(s.Lc)(a,"prelu weights","fused matMul"));const E=(t,e)=>{const[a,i,u,l]=e,b=Object(s.rc)(Object(s.N)(t,u.shape),u,c);let h,d;if(n||r?!n&&r?(h=Object(s.P)(b,i,!1,!1),d=Object(s.P)(b,a,!0,!1)):n&&!r?(h=Object(s.P)(i,b,!1,!0),d=Object(s.P)(a,b,!1,!1)):(h=Object(s.P)(i,b,!0,!0),d=Object(s.P)(b,a,!0,!0)):(h=Object(s.P)(b,i,!1,!0),d=Object(s.P)(a,b,!0,!1)),null!=o){return[h,d,Object(s.vc)(l,b)]}return[h,d]},M={a:w,b:y,bias:x,preluActivationWeights:v},N={transposeA:n,transposeB:r,activation:c,leakyreluAlpha:i};if(null==o){return Object(s.pc)(((t,e,n)=>{const r=s.Oc.runKernel(s.zc,M,N);return n([t,e,r]),{value:Object(s.N)(r,g),gradFunc:E}}))(w,y)}return Object(s.pc)(((t,e,n,r)=>{const o=s.Oc.runKernel(s.zc,M,N);return r([t,e,o,n]),{value:Object(s.N)(o,g),gradFunc:E}}))(w,y,x)}});Object(s.Mc)({hammingWindow_:function(t){return J(t,.54,.46)}});const et=Object(s.Mc)({hannWindow_:function(t){return J(t,.5,.5)}});const nt=Object(s.Mc)({frame_:function(t,e,n,r=!1,o=0){let c=0;const a=[];for(;c+e<=t.size;)a.push(Object(s.pb)(t,c,e)),c+=n;if(r)for(;c<t.size;){const r=c+e-t.size,i=Object(s.K)([Object(s.pb)(t,c,e-r),v([r],o)]);a.push(i),c+=n}return 0===a.length?q([],[0,e]):Object(s.N)(Object(s.K)(a),[a.length,e])}});Object(s.Mc)({stft_:function(t,e,n,r,o=et){var c;null==r&&(c=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(c)/Math.log(2)))));const a=nt(t,e,n),i=Object(s.mh)(a,o(e)),u=[];for(let t=0;t<a.shape[0];t++)u.push(Object(s.lb)(Object(s.pb)(i,[t,0],[1,e]),r));return Object(s.K)(u)}});const rt=Object(s.Mc)({cropAndResize_:function(t,e,n,r,o="bilinear",c=0){const a=Object(s.Lc)(t,"image","cropAndResize"),i=Object(s.Lc)(e,"boxes","cropAndResize","float32"),u=Object(s.Lc)(n,"boxInd","cropAndResize","int32"),l=i.shape[0];Object(s.F)(4===a.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`)),Object(s.F)(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`)),Object(s.F)(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`)),Object(s.F)(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Object(s.F)(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Object(s.F)("bilinear"===o||"nearest"===o,(()=>`method must be bilinear or nearest, but was ${o}`));const b={image:a,boxes:i,boxInd:u},h={method:o,extrapolationValue:c,cropSize:r};return s.Oc.runKernel(s.Ac,b,h)}});const st=Object(s.Mc)({flipLeftRight_:function(t){const e=Object(s.Lc)(t,"image","flipLeftRight","float32");Object(s.F)(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return s.Oc.runKernel(s.Bc,n,{})}});const ot=Object(s.Mc)({rotateWithOffset_:function(t,e,n=0,r=.5){const o=Object(s.Lc)(t,"image","rotateWithOffset","float32");Object(s.F)(4===o.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`));const c={image:o},a={radians:e,fillValue:n,center:r};return s.Oc.runKernel(s.Qb,c,a)}});function ct(t,e,n,r,o,c){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==c&&(c=0);const a=t.shape[0];return n=Math.min(n,a),Object(s.F)(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Object(s.F)(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),Object(s.F)(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),Object(s.F)(1===e.rank,(()=>"scores must be a 1D tensor")),Object(s.F)(e.shape[0]===a,(()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`)),Object(s.F)(0<=c&&c<=1,(()=>`softNmsSigma must be in [0, 1], but was '${c}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:c}}const at=Object(s.Mc)({nonMaxSuppression_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY){const c=Object(s.Lc)(t,"boxes","nonMaxSuppression"),a=Object(s.Lc)(e,"scores","nonMaxSuppression"),i=ct(c,a,n,r,o),u={maxOutputSize:n=i.maxOutputSize,iouThreshold:r=i.iouThreshold,scoreThreshold:o=i.scoreThreshold};return s.Oc.runKernel(s.ed,{boxes:c,scores:a},u)}});const it=async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY){const c=Object(s.Lc)(t,"boxes","nonMaxSuppressionAsync"),a=Object(s.Lc)(e,"scores","nonMaxSuppressionAsync"),i=ct(c,a,n,r,o);n=i.maxOutputSize,r=i.iouThreshold,o=i.scoreThreshold;const u=await Promise.all([c.data(),a.data()]),l=u[0],b=u[1],{selectedIndices:h}=Object(s.fd)(l,b,n,r,o);return c!==t&&c.dispose(),a!==e&&a.dispose(),V(h,"int32")};const ut=Object(s.Mc)({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=0){const a=Object(s.Lc)(t,"boxes","nonMaxSuppression"),i=Object(s.Lc)(e,"scores","nonMaxSuppression"),u=ct(a,i,n,r,o,c),l={boxes:a,scores:i},b={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:o=u.scoreThreshold,softNmsSigma:c=u.softNmsSigma},h=s.Oc.runKernel(s.gd,l,b);return{selectedIndices:h[0],selectedScores:h[1]}}});const lt=async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=0){const a=Object(s.Lc)(t,"boxes","nonMaxSuppressionAsync"),i=Object(s.Lc)(e,"scores","nonMaxSuppressionAsync"),u=ct(a,i,n,r,o,c);n=u.maxOutputSize,r=u.iouThreshold,o=u.scoreThreshold,c=u.softNmsSigma;const l=await Promise.all([a.data(),i.data()]),b=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=Object(s.hd)(b,h,n,r,o,c);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:V(d,"int32"),selectedScores:V(p)}};const bt=Object(s.Mc)({nonMaxSuppressionPadded_:function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=!1){const a=Object(s.Lc)(t,"boxes","nonMaxSuppression"),i=Object(s.Lc)(e,"scores","nonMaxSuppression"),u=ct(a,i,n,r,o,null),l={boxes:a,scores:i},b={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:c},h=s.Oc.runKernel(s.id,l,b);return{selectedIndices:h[0],validOutputs:h[1]}}});const ht=async function(t,e,n,r=.5,o=Number.NEGATIVE_INFINITY,c=!1){const a=Object(s.Lc)(t,"boxes","nonMaxSuppressionAsync"),i=Object(s.Lc)(e,"scores","nonMaxSuppressionAsync"),u=ct(a,i,n,r,o,null),l=u.maxOutputSize,b=u.iouThreshold,h=u.scoreThreshold,[d,p]=await Promise.all([a.data(),i.data()]),{selectedIndices:O,validOutputs:f}=Object(s.jd)(d,p,l,b,h,c);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:V(O,"int32"),validOutputs:Object(s.G)(f,"int32")}};Object(s.Mc)({bandPart_:function(t,e,n){Object(s.F)(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),Object(s.F)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=Object(s.Lc)(t,"a","bandPart");Object(s.F)(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const o=r.shape,[c,a]=r.shape.slice(-2);if(!(e<=c))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${c}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=c),n<0&&(n=a);const i=Object(s.N)(G(0,c,1,"int32"),[-1,1]),u=G(0,a,1,"int32"),l=Object(s.Pb)(i,u),b=Object(s.Ib)(Object(s.Jb)(l,Object(s.G)(+e,"int32")),Object(s.Lb)(l,Object(s.G)(-n,"int32"))),h=Object(s.yb)([c,a],r.dtype);return Object(s.N)(Object(s.J)(Object(s.L)(Object(s.N)(r,[-1,c,a])).map((t=>Object(s.Fb)(b,t,h)))),o)}});Object(s.Mc)({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Object(s.F)(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)Object(s.F)(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=Object(s.db)(t,t.shape[0],0).map((t=>Object(s.fb)(t,[0])));Object(s.F)(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],r=t;for(let e=0;e<t.length;++e)n.push(s.Oc.tidy((()=>{let t=r[e];if(e>0)for(let r=0;r<e;++r){const e=Object(s.mh)(Object(s.Z)(Object(s.mh)(n[r],t)),n[r]);t=Object(s.Pb)(t,e)}return Object(s.kh)(t,Object(s.kd)(t,"euclidean"))})));return e?Object(s.J)(n,0):n}});function dt(t,e=!1){return s.Oc.tidy((()=>{Object(s.F)(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],r=t.shape[1];let o=x(n),c=Object(s.cd)(t);const a=q([[1]],[1,1]);let i=Object(s.cd)(a);const u=n>=r?r:n;for(let t=0;t<u;++t){const e=c,u=i,l=o;[i,c,o]=s.Oc.tidy((()=>{const e=Object(s.pb)(c,[t,t],[n-t,1]),u=Object(s.kd)(e),l=Object(s.pb)(c,[t,t],[1,1]),b=Object(s.Fb)(Object(s.Mb)(l,0),q([[-1]]),q([[1]])),h=Object(s.Pb)(l,Object(s.mh)(b,u)),d=Object(s.kh)(e,h);i=1===d.shape[0]?Object(s.cd)(a):Object(s.K)([a,Object(s.pb)(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Object(s.j)(Object(s.kh)(Object(s.P)(b,h),u)),O=Object(s.pb)(c,[t,0],[n-t,r]),f=Object(s.mh)(p,i),j=Object(s.O)(i);if(0===t)c=Object(s.Pb)(O,Object(s.P)(f,Object(s.P)(j,O)));else{const e=Object(s.Pb)(O,Object(s.P)(f,Object(s.P)(j,O)));c=Object(s.K)([Object(s.pb)(c,[0,0],[t,r]),e],0)}const m=Object(s.O)(f),g=Object(s.pb)(o,[0,t],[n,o.shape[1]-t]);if(0===t)o=Object(s.Pb)(g,Object(s.P)(Object(s.P)(g,i),m));else{const e=Object(s.Pb)(g,Object(s.P)(Object(s.P)(g,i),m));o=Object(s.K)([Object(s.pb)(o,[0,0],[n,t]),e],1)}return[i,c,o]})),Object(s.ld)([e,u,l])}return!e&&n>r&&(o=Object(s.pb)(o,[0,0],[n,r]),c=Object(s.pb)(c,[0,0],[r,r])),[o,c]}))}Object(s.Mc)({qr_:function(t,e=!1){if(Object(s.F)(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return dt(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=Object(s.L)(Object(s.N)(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],c=[];r.forEach((t=>{const[n,r]=dt(t,e);o.push(n),c.push(r)}));return[Object(s.N)(Object(s.J)(o,0),t.shape),Object(s.N)(Object(s.J)(c,0),t.shape)]}}});var pt;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(pt||(pt={}));const Ot=Object(s.Mc)({computeWeightedLoss_:function(t,e,n=pt.SUM_BY_NONZERO_WEIGHTS){const r=Object(s.Lc)(t,"losses","computeWeightedLoss");let o=null;null!=e&&(o=Object(s.Lc)(e,"weights","computeWeightedLoss"));const c=null==o?r:Object(s.mh)(r,o);if(n===pt.NONE)return c;if(n===pt.SUM)return Object(s.Z)(c);if(n===pt.MEAN){if(null==o)return Object(s.bb)(c);{const t=r.size/o.size,e=Object(s.kh)(Object(s.Z)(c),Object(s.Z)(o));return t>1?Object(s.kh)(e,Object(s.G)(t)):e}}if(n===pt.SUM_BY_NONZERO_WEIGHTS){if(null==o)return Object(s.kh)(Object(s.Z)(c),Object(s.G)(r.size));{const t=Object(s.mh)(o,Object(s.Ab)(r.shape)),e=Object(s.Cb)(Object(s.Z)(Object(s.Nb)(t,Object(s.G)(0))),"float32");return Object(s.kh)(Object(s.Z)(c),e)}}throw Error(`Unknown reduction: ${n}`)}});Object(s.Mc)({absoluteDifference_:function(t,e,n,r=pt.SUM_BY_NONZERO_WEIGHTS){const o=Object(s.Lc)(t,"labels","absoluteDifference"),c=Object(s.Lc)(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=Object(s.Lc)(n,"weights","absoluteDifference")),Object(s.md)(o.shape,c.shape,"Error in absoluteDifference: ");const i=Object(s.E)(Object(s.Pb)(o,c));return Ot(i,a,r)}});Object(s.Mc)({cosineDistance_:function(t,e,n,r,o=pt.SUM_BY_NONZERO_WEIGHTS){const c=Object(s.Lc)(t,"labels","cosineDistance"),a=Object(s.Lc)(e,"predictions","cosineDistance");let i=null;null!=r&&(i=Object(s.Lc)(r,"weights","cosineDistance")),Object(s.md)(c.shape,a.shape,"Error in cosineDistance: ");const u=Object(s.G)(1),l=Object(s.Pb)(u,Object(s.Z)(Object(s.mh)(c,a),n,!0));return Ot(l,i,o)}});Object(s.Mc)({hingeLoss_:function(t,e,n,r=pt.SUM_BY_NONZERO_WEIGHTS){let o=Object(s.Lc)(t,"labels","hingeLoss");const c=Object(s.Lc)(e,"predictions","hingeLoss");let a=null;null!=n&&(a=Object(s.Lc)(n,"weights","hingeLoss")),Object(s.md)(o.shape,c.shape,"Error in hingeLoss: ");const i=Object(s.G)(1);o=Object(s.Pb)(Object(s.mh)(Object(s.G)(2),o),i);const u=Object(s.g)(Object(s.Pb)(i,Object(s.mh)(o,c)));return Ot(u,a,r)}});Object(s.Mc)({huberLoss_:function(t,e,n,r=1,o=pt.SUM_BY_NONZERO_WEIGHTS){const c=Object(s.Lc)(t,"labels","huberLoss"),a=Object(s.Lc)(e,"predictions","huberLoss");let i=null;null!=n&&(i=Object(s.Lc)(n,"weights","huberLoss")),Object(s.md)(c.shape,a.shape,"Error in huberLoss: ");const u=Object(s.G)(r),l=Object(s.E)(Object(s.Pb)(a,c)),b=Object(s.C)(l,u),h=Object(s.Pb)(l,b),d=Object(s.oh)(Object(s.mh)(Object(s.G)(.5),Object(s.Bh)(b)),Object(s.mh)(u,h));return Ot(d,i,o)}});Object(s.Mc)({logLoss_:function(t,e,n,r=1e-7,o=pt.SUM_BY_NONZERO_WEIGHTS){const c=Object(s.Lc)(t,"labels","logLoss"),a=Object(s.Lc)(e,"predictions","logLoss");let i=null;null!=n&&(i=Object(s.Lc)(n,"weights","logLoss")),Object(s.md)(c.shape,a.shape,"Error in logLoss: ");const u=Object(s.G)(1),l=Object(s.G)(r),b=Object(s.j)(Object(s.mh)(c,Object(s.m)(Object(s.oh)(a,l)))),h=Object(s.mh)(Object(s.Pb)(u,c),Object(s.m)(Object(s.oh)(Object(s.Pb)(u,a),l))),d=Object(s.Pb)(b,h);return Ot(d,i,o)}});Object(s.Mc)({meanSquaredError_:function(t,e,n,r=pt.SUM_BY_NONZERO_WEIGHTS){const o=Object(s.Lc)(t,"labels","meanSquaredError"),c=Object(s.Lc)(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=Object(s.Lc)(n,"weights","meanSquaredError")),Object(s.md)(o.shape,c.shape,"Error in meanSquaredError: ");const i=Object(s.xh)(o,c);return Ot(i,a,r)}});Object(s.Mc)({sigmoidCrossEntropy_:function(t,e,n,r=0,o=pt.SUM_BY_NONZERO_WEIGHTS){let c=Object(s.Lc)(t,"multiClassLabels","sigmoidCrossEntropy");const a=Object(s.Lc)(e,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Object(s.Lc)(n,"weights","sigmoidCrossEntropy")),Object(s.md)(c.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=Object(s.G)(r),e=Object(s.G)(1),n=Object(s.G)(.5);c=Object(s.oh)(Object(s.mh)(c,Object(s.Pb)(e,t)),Object(s.mh)(n,t))}const u=function(t,e){const n=Object(s.Lc)(t,"labels","sigmoidCrossEntropyWithLogits"),r=Object(s.Lc)(e,"logits","sigmoidCrossEntropyWithLogits");Object(s.md)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const o=Object(s.g)(r),c=Object(s.mh)(r,n),a=Object(s.l)(Object(s.p)(Object(s.j)(Object(s.E)(r))));return Object(s.oh)(Object(s.Pb)(o,c),a)}(c,a);return Ot(u,i,o)}});Object(s.Mc)({softmaxCrossEntropy_:function(t,e,n,r=0,o=pt.SUM_BY_NONZERO_WEIGHTS){let c=Object(s.Lc)(t,"onehotLabels","softmaxCrossEntropy");const a=Object(s.Lc)(e,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Object(s.Lc)(n,"weights","softmaxCrossEntropy")),Object(s.md)(c.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const t=Object(s.G)(r),e=Object(s.G)(1),n=Object(s.G)(c.shape[1]);c=Object(s.oh)(Object(s.mh)(c,Object(s.Pb)(e,t)),Object(s.kh)(t,n))}const u=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Object(s.pc)(((t,e,r)=>{const o=Object(s.nd)(e,[n],!0),c=Object(s.Pb)(Object(s.Cb)(e,"float32"),o);r([t,c]);const a=Object(s.j)(Object(s.mh)(c,t));return{value:Object(s.Z)(a,[n]),gradFunc:(t,e)=>{const[r,o]=e,c=Object(s.Pd)(t.shape,[n]);return[Object(s.mh)(Object(s.N)(t,c),Object(s.Pb)(Object(s.Cb)(r,"float32"),Object(s.p)(o))),Object(s.mh)(Object(s.N)(t,c),Object(s.Pb)(Object(s.p)(o),Object(s.Cb)(r,"float32")))]}}}))(t,e)}(c,a);return Ot(u,i,o)}}),s.nb,s.mb,s.lb,s.kb;const ft={flipLeftRight:st,resizeNearestNeighbor:s.Qd,resizeBilinear:s.Rd,rotateWithOffset:ot,cropAndResize:rt,nonMaxSuppression:at,nonMaxSuppressionAsync:it,nonMaxSuppressionWithScore:ut,nonMaxSuppressionWithScoreAsync:lt,nonMaxSuppressionPadded:bt,nonMaxSuppressionPaddedAsync:ht}}}]);